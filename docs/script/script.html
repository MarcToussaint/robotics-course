<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lecture Script &mdash; Robotics Python Library  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Old Material" href="../old/old.html" />
    <link rel="prev" title="Path finding example" href="../tutorials/script5-PathFind.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Robotics Python Library
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Lecture Script</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reference-material">Reference material</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coding-getting-started">Coding Getting Started</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#scene-robot-description">Scene &amp; Robot Description</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#transformations">Transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coordinates-and-composition-of-transformations">Coordinates and Composition of Transformations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scene-tree-or-forest">Scene Tree or Forest</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#kinematics">Kinematics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#robots-as-parameterized-trees">Robots as Parameterized Trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuration-joint-vector">Configuration &amp; Joint Vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#forward-kinematics">Forward Kinematics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#jacobians">Jacobians</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rotational-joint">Rotational Joint</a></li>
<li class="toctree-l4"><a class="reference internal" href="#translational-joint">Translational Joint</a></li>
<li class="toctree-l4"><a class="reference internal" href="#quaternion-joint">Quaternion Joint</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#general-concept-of-differentiable-features">General Concept of Differentiable Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#summary-implementing-a-kinematic-engine">Summary: Implementing a Kinematic Engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inverse-kinematics">Inverse Kinematics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#building-an-nlp-from-features">Building an NLP from features</a></li>
<li class="toctree-l4"><a class="reference internal" href="#classical-derivation-of-pseudo-inverse-jacobian-solution">Classical Derivation of Pseudo-Inverse Jacobian Solution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#placeholder">Placeholder</a></li>
<li class="toctree-l2"><a class="reference internal" href="#practical-control-pid-splines-tracking-layes-of-control">Practical Control: PID, Splines, Tracking, &amp; Layes of Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#path-planning">Path Planning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#path-optimization-briefly">Path Optimization – briefly</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mobile-robotics">Mobile Robotics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#control-theory">Control Theory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#skipped-this-term-grasping-brief-intro">SKIPPED THIS TERM – Grasping (brief intro)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#skipped-this-term-legged-locomotion-brief-intro">SKIPPED THIS TERM – Legged Locomotion (brief intro)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#d-transformations-rotations-quaternions">3D Transformations, Rotations, Quaternions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#rotations">Rotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transformations-1">Transformations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#static-transformations">Static transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-transformations">Dynamic transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#a-note-on-affine-coordinate-frames">A note on affine coordinate frames</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rai-references">RAI references</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nlp-interface">NLP interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kinematic-features">Kinematic Features</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graph-yaml-files">Graph-Yaml Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#yaml-style-files-to-describe-robot-configurations">yaml-style files to describe robot configurations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#editing-using-kinedit">Editing using <code class="docutils literal notranslate"><span class="pre">kinEdit</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#import-from-urdf">Import from URDF</a></li>
<li class="toctree-l4"><a class="reference internal" href="#notation-to-specify-transformations">Notation to specify transformations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#joint-types">Joint types</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cameras">Cameras</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#image-camera-world-coordinates">Image, Camera, &amp; World Coordinates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#homogeneous-coordinates-camera-matrix-p">Homogeneous coordinates &amp; Camera Matrix <span class="math notranslate nohighlight">\(P\)</span></a></li>
<li class="toctree-l3"><a class="reference internal" href="#calibration-as-estimating-p-k-r-t-from-depth-data">Calibration as Estimating <span class="math notranslate nohighlight">\(P,K,R,t\)</span> from Depth Data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#placeholder-1">Placeholder</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shapes">Shapes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kinematics-formally">Kinematics formally</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../old/old.html">Old Material</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rai.html">rai python API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Robotics Python Library</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Lecture Script</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="lecture-script">
<h1>Lecture Script<a class="headerlink" href="#lecture-script" title="Permalink to this heading"></a></h1>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<section id="reference-material">
<h3>Reference material<a class="headerlink" href="#reference-material" title="Permalink to this heading"></a></h3>
<p>In terms of background, please refer to the USE PDFLATEX! as well as the
USE PDFLATEX! lecture scripts. Here a list of further teaching material:</p>
<ul>
<li><p>Craig, J.J.: <em>Introduction to robotics: mechanics and control</em>.
Addison-Wesley New York, 1989. (3rd edition 2006)</p></li>
<li><p>Steven M. LaValle: <em>Planning Algorithms</em>. Cambridge University Press,
2006.</p>
<p><strong>online:</strong> <a class="reference external" href="http://planning.cs.uiuc.edu/">http://planning.cs.uiuc.edu/</a></p>
</li>
<li><p>VideoLecture by Oussama Khatib:
&lt;<a class="reference external" href="http://videolectures.net/oussama_khatib/">http://videolectures.net/oussama_khatib/</a>&gt;</p>
<p>(focus on kinematics, dynamics, control)</p>
</li>
<li><p>Oliver Brock’s lecture
&lt;<a class="reference external" href="http://www.robotics.tu-berlin.de/menue/teaching/">http://www.robotics.tu-berlin.de/menue/teaching/</a>&gt;</p></li>
<li><p>Stefan Schaal’s lecture Introduction to Robotics:
&lt;<a class="reference external" href="http://www-clmc.usc.edu/Teaching/TeachingIntroductionToRoboticsSyllabus">http://www-clmc.usc.edu/Teaching/TeachingIntroductionToRoboticsSyllabus</a>&gt;</p>
<p>(focus on control, useful: Basic Linear Control Theory (analytic
solution to simple dynamic model <span class="math notranslate nohighlight">\(\to\)</span> PID), chapter on
dynamics)</p>
</li>
<li><p>Chris Atkeson’s “Kinematics, Dynamic Systems, and Control”
&lt;<a class="reference external" href="http://www.cs.cmu.edu/">http://www.cs.cmu.edu/</a> cga/kdc/&gt;</p>
<p>(uses Schaal’s slides and LaValle’s book, useful: slides on 3d
kinematics &lt;<a class="reference external" href="http://www.cs.cmu.edu/">http://www.cs.cmu.edu/</a> cga/kdc-10/ewhitman1.pptx&gt;)</p>
</li>
<li><p>CMU lecture “introduction to robotics”
&lt;<a class="reference external" href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/16311/www/current/">http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/16311/www/current/</a>&gt;</p>
<p>(useful: PID control, simple BUGs algorithms for motion planning,
non-holonomic constraints)</p>
</li>
<li><p><em>Springer Handbook of Robotics, Bruno Siciliano, Oussama Khatib</em>
&lt;<a class="reference external" href="http://link.springer.com/book/10.1007/978-3-319-32552-1">http://link.springer.com/book/10.1007/978-3-319-32552-1</a>&gt;</p></li>
<li><p>LaValle’s <em>Planning Algorithms</em> &lt;<a class="reference external" href="http://planning.cs.uiuc.edu/">http://planning.cs.uiuc.edu/</a>&gt;</p></li>
</ul>
</section>
<section id="coding-getting-started">
<h3>Coding Getting Started<a class="headerlink" href="#coding-getting-started" title="Permalink to this heading"></a></h3>
<p>The coding secitons use the <code class="docutils literal notranslate"><span class="pre">robotic</span></code> python package. Sources and
dockers to build the wheel are found on USE PDFLATEX!.</p>
<p>To install on a standard Ubuntu, the following should be sufficient</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sudo</span> <span class="n">apt</span> <span class="n">install</span> <span class="n">liblapack3</span> <span class="n">freeglut3</span> <span class="n">libglew</span><span class="o">-</span><span class="n">dev</span> <span class="n">python3</span> <span class="n">python3</span><span class="o">-</span><span class="n">pip</span>
<span class="n">python3</span> <span class="o">-</span><span class="n">m</span> <span class="n">pip</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span> <span class="n">robotic</span> <span class="n">numpy</span> <span class="n">scipy</span>
</pre></div>
</div>
<p>A standard test is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python3</span> <span class="o">-</span><span class="n">c</span> <span class="s1">&#39;from robotic import ry; ry.test.RndScene()&#39;</span>
</pre></div>
</div>
<p>Several USE PDFLATEX! are available as part of the USE PDFLATEX!.</p>
</section>
</section>
<section id="scene-robot-description">
<h2>Scene &amp; Robot Description<a class="headerlink" href="#scene-robot-description" title="Permalink to this heading"></a></h2>
<p>Generally speaking, a scene is a collection of objects (including robot
parts). We typically assume objects to be rigid bodies with fixed shape
– which clearly is a simplification relative to real world. More about
this below, in section 1.15.1.</p>
<p>However, formally we define a scene as a collection of <strong>frames</strong>, which
is short for coordinate frames. We can think of these frames as oriented
locations in 3D space – and various things can be associated to these
frames. If a rigid shape and mass is associated to a frame, then it
makes a typical rigid body. But frames can also be associated to robot
joint locations or virtual landmarks.</p>
<section id="transformations">
<h3>Transformations<a class="headerlink" href="#transformations" title="Permalink to this heading"></a></h3>
<p>Let <span class="math notranslate nohighlight">\(i=1,..,m\)</span> enumerate <span class="math notranslate nohighlight">\(m\)</span> frames in a scene. Each frame
has a <strong>pose</strong> <span class="math notranslate nohighlight">\(X_i\in SE(3)\)</span>, where
<span class="math notranslate nohighlight">\(SE(3) = {\mathbb{R}}^3 \times SO(3)\)</span> is the group of 3D
transformations, namely the cross-product of translations and rotations.
We always assume a world origin to be defined and use the word <em>pose</em>
specifically for the transformation from world origin to the object
frame.</p>
<p>Transformations in <span class="math notranslate nohighlight">\(A\in SE(3)\)</span> are tuples <span class="math notranslate nohighlight">\(A = (t, r)\)</span>,
where <span class="math notranslate nohighlight">\(t\in{\mathbb{R}}^3\)</span> is a translation and <span class="math notranslate nohighlight">\(r\in SO(3)\)</span>
a rotation – see Appendix 1.12 for more details.
Rotations can be represented as matrix <span class="math notranslate nohighlight">\(R\)</span> (see the Maths script
on properties of rotation matrices), and a pose as the <span class="math notranslate nohighlight">\(4\times 4\)</span>
homogeneous transform
<span class="math notranslate nohighlight">\(\left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right)\)</span>.
However, more commonly in code we represent rotations as a 4D quaternion
<span class="math notranslate nohighlight">\(r\in{\mathbb{R}}^4\)</span> with unit length <span class="math notranslate nohighlight">\(|r| = 1\)</span>. I always
use the convention <span class="math notranslate nohighlight">\(r=(r_0,\bar r)\)</span>, where the first entry
<span class="math notranslate nohighlight">\(r_0 = \cos(\theta/2)\)</span> relates to the total rotation angle
<span class="math notranslate nohighlight">\(\theta\)</span>, and the last three entries
<span class="math notranslate nohighlight">\(\bar r = \sin(\theta/2)~ \underline w\)</span> relate to the unit length
rotation axis <span class="math notranslate nohighlight">\(\underline w\)</span>.</p>
<p>Euler angles and the scaled rotation vector are alternative rotation
representations – but never use them.</p>
<p>See appendix 1.12 for reference and conversions.</p>
<p>Let’s create a mini scene of 2 frames, both have no proper shape but
just a “marker” displaying their axes. We create a yaml-style <code class="docutils literal notranslate"><span class="pre">mini.g</span></code>
file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">:</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.5</span><span class="p">]</span> <span class="p">}</span>
<span class="n">B</span><span class="p">:</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">X</span></code> provides the pose of frame <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, given
with 7 numbers, which are translation and quaternion. Let’s load and
display it:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">robotic</span> <span class="kn">import</span> <span class="n">ry</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">ry</span><span class="o">.</span><span class="n">Config</span><span class="p">()</span>
<span class="n">C</span><span class="o">.</span><span class="n">addFile</span><span class="p">(</span><span class="s1">&#39;mini.g&#39;</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
</pre></div>
</div>
<p>and you’ll see the two markers in places <span class="math notranslate nohighlight">\((1,0,1)\)</span> and
<span class="math notranslate nohighlight">\((-1,0,1)\)</span>.</p>
<p>Providing quaternions is rather non-intuitive for a human. So there is a
second convention of how to specify transformations in a more
human-intuitive manner with turtle commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">:</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span> <span class="s2">&quot;t(1 0 1) d(30 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.5</span><span class="p">]</span> <span class="p">}</span>
<span class="n">B</span><span class="p">:</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span> <span class="s2">&quot;t(-1 0 1) d(90 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the string is interpreted as sequential commands of translation
(t), and rotation by degrees around an axis (d). These can be sequenced
to specify the full transform more intuitively. Also Euler angle
commands (E), rotation by radians (r), and a quaternion (q) are
interpreted. Play around with this and see how the frame poses change.
To reload you can also try calling</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">C</span><span class="o">.</span><span class="n">watchFile</span><span class="p">(</span><span class="s1">&#39;mini.g&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>which is a helper that automatically updates the display whenever the
file changes – but doesn’t always handle file syntax errors well.</p>
</section>
<section id="coordinates-and-composition-of-transformations">
<h3>Coordinates and Composition of Transformations<a class="headerlink" href="#coordinates-and-composition-of-transformations" title="Permalink to this heading"></a></h3>
<p><img alt="image" src="script/caption" /></p>
<p>[figTransforms] Composition of transforms.</p>
<p>Consider Fig. [figTransforms], were we have three
frames <span class="math notranslate nohighlight">\(1,2,3\)</span> in addition to the world origin frame <span class="math notranslate nohighlight">\(W\)</span>.
Each frame has a global pose <span class="math notranslate nohighlight">\(X_1, X_2, X_3\)</span>, and relative
transforms <span class="math notranslate nohighlight">\(Q_{W\to 1}, Q_{1\to 2}, Q_{2\to 3}\)</span>. We have</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
X_1 &amp;= Q_{W\to 1} \\
X_2 &amp;= Q_{W\to 1} \circ Q_{1\to2} \\
X_3 &amp;= Q_{W\to 1} \circ Q_{1\to2} \circ Q_{1\to3} ~.\end{aligned}\end{split}\]</div>
<p>Note that when composing relative transforms, we concatenate (append)
them <em>on the right</em>! Intuitively, this describes a concatenation of
turtle commands, where a turtle is initially placed on the world origin,
then translates, then rotations, then translates <em>relative to its own
pose</em>, then rotations <em>relative to its own pose</em>, etc, and ends up in
pose <span class="math notranslate nohighlight">\(X_3\)</span>.</p>
<p>Now consider the position of a point in 3D space. It can be given in
world coordinates <span class="math notranslate nohighlight">\(x^W\)</span>, but also in relative coordinates
<span class="math notranslate nohighlight">\(x^1, x^2, x^3\)</span>. We have</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
x^W &amp;= Q_{W\to 1}~ Q_{1\to2}~ Q_{1\to3}~ x^3 = X_3~ x^3 ~.\end{aligned}\]</div>
<p>Now you might want to ask: “does <span class="math notranslate nohighlight">\(Q_{1\to 2}\)</span> describe the forward
or the backward transformation from frame <span class="math notranslate nohighlight">\(1\)</span> to frame <span class="math notranslate nohighlight">\(2\)</span>?”
But this question is somewhat ill-posed. The situation is:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(Q_{1\to 2}\)</span> describes the translation and rotation of <em>frame</em>
<span class="math notranslate nohighlight">\(2\)</span> <em>relative</em> to <span class="math notranslate nohighlight">\(1\)</span>. So you may call it the “forward
FRAME transformation”.</p></li>
<li><p><span class="math notranslate nohighlight">\(Q_{1\to 2}\)</span> describes the coordinate transformation from
<span class="math notranslate nohighlight">\(x^2\)</span> to <span class="math notranslate nohighlight">\(x^1 = Q_{1\to 2} x^2\)</span>. So you may call it the
“backward COORDINATE transformation”.</p></li>
</ul>
<p>In the view of fundamental linear algebra, this should not surprise as
vectors (and frames) transform <em>covariant</em>, while coordinates transform
<em>contra-variant</em>. See the maths lecture.</p>
<p>Let’s make the <code class="docutils literal notranslate"><span class="pre">mini.g</span></code> scene to represent a sequence of frames:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">:</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span> <span class="s2">&quot;t(1 0 1) d(30 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.5</span><span class="p">]</span> <span class="p">}</span>
<span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span> <span class="p">{</span> <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;t(-1 0 1) d(90 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">]</span> <span class="p">}</span>
<span class="n">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span> <span class="p">{</span> <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;t(0 0 .5) d(30 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">],</span> <span class="n">color</span><span class="p">:[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Relative to the above, we made <span class="math notranslate nohighlight">\(B\)</span> a frame <em>relative</em> to
<span class="math notranslate nohighlight">\(A\)</span>, i.e., <span class="math notranslate nohighlight">\(B\)</span> is now a child of <span class="math notranslate nohighlight">\(A\)</span>, and added
another child <span class="math notranslate nohighlight">\(C\)</span> of <span class="math notranslate nohighlight">\(B\)</span>. Note that instead of specifying
the pose <span class="math notranslate nohighlight">\(X\)</span>, we now have to specify the relative transform
<span class="math notranslate nohighlight">\(Q\)</span>.</p>
</section>
<section id="scene-tree-or-forest">
<h3>Scene Tree or Forest<a class="headerlink" href="#scene-tree-or-forest" title="Permalink to this heading"></a></h3>
<p>Scenes are typically represented as trees, with the world origin as a
root, and the pose of children specified by a <em>relative</em> transformation
from the parent. For instance, a scene with a book on a table on the
ground on the world, would have four frames with poses
<span class="math notranslate nohighlight">\(X_0, X_1, X_2, X_3\)</span> (of the world, ground, table, book), but the
scene would typically be represented by relative transforms
<span class="math notranslate nohighlight">\(Q_1, Q_2, Q_3\)</span> such that</p>
<div class="math notranslate nohighlight">
\[X_i = X_{i{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}} \circ Q_i ~.\]</div>
<p>Note that every frame can only have a single parent, and we can
abbreviate the notation <span class="math notranslate nohighlight">\(Q_i \equiv Q_{\text{parent}(i)\to i}\)</span>.</p>
<p>Scenes can also be a forest of frames, where some frames have no parent
and their pose <span class="math notranslate nohighlight">\(X_i\)</span> must be specified, while for non-roots the
relative transform <span class="math notranslate nohighlight">\(Q_i\)</span> is specified. We usually only talk about
trees, but include meaning forests.</p>
</section>
</section>
<section id="kinematics">
<h2>Kinematics<a class="headerlink" href="#kinematics" title="Permalink to this heading"></a></h2>
<section id="robots-as-parameterized-trees">
<h3>Robots as Parameterized Trees<a class="headerlink" href="#robots-as-parameterized-trees" title="Permalink to this heading"></a></h3>
<p>The key thing in robotics is that some relative transforms (between
robot links) are “motorized” and can be moved. Formally, this means that
<em>some</em> of the relative transforms <span class="math notranslate nohighlight">\(Q_i\)</span> in our scene have
<strong>degrees of freedom</strong> (dof) <span class="math notranslate nohighlight">\(q_i \in {\mathbb{R}}^{d_i}\)</span>.</p>
<p>For typical robots (with hinge or linear joints) each <span class="math notranslate nohighlight">\(q_i\)</span> is
just a single number (the joint dimensionality <span class="math notranslate nohighlight">\(d_i=1\)</span>). E.g., a
<strong>hinge</strong> joint around the (local) <span class="math notranslate nohighlight">\(x\)</span>-axis has a single dof
<span class="math notranslate nohighlight">\(q_i\in{\mathbb{R}}\)</span> that parameterizes the relative transform</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
Q_i(q_i) =  \left(\begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; \cos(q_i) &amp; -\sin(q) &amp; 0 \\
0 &amp;  \sin(q_i) &amp; \cos(q) &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>And a <strong>prismatic</strong> (or translational) joint along the (local)
<span class="math notranslate nohighlight">\(x\)</span>-axis parameterizes</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
Q_i(q_i) =  \left(\begin{array}{cccc}
1 &amp; 0 &amp; 0 &amp; q \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Other joint types (universal, cylindrical) are less common.</p>
<p>A bit special are <strong>ball (spherical) joints</strong>: They parameterize
arbitrary rotations within <span class="math notranslate nohighlight">\(Q_i\)</span> – in principle they could be
described as having 3 dofs (as the Lie group <span class="math notranslate nohighlight">\(SO(3)\)</span> is a 3D
manifold), however, in code it is practice to again use quaternions to
parameterize rotations, which means <span class="math notranslate nohighlight">\(q_i\in{\mathbb{R}}^4\)</span> for
ball joints. However, note that this is an over parameterization: If
<span class="math notranslate nohighlight">\(q_i\)</span> is externally “set” by a user or some algorithm, it may not
(exactly) be normalized but <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span> is defined to be the proper
rotation that corresponds to the quaternion <span class="math notranslate nohighlight">\(q_i/|q_i|\)</span>. Note that
if a user or algorithms sets such a quaternion parameter to zero, that’s
a singularity and strict error.</p>
<p>In the scene tree, some of the relative transforms <span class="math notranslate nohighlight">\(Q_i\)</span> are
parameterized by dofs, <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span>. Note that
<span class="math notranslate nohighlight">\(X_\text{parent$(i)$}\)</span> is the <strong>joint base frame</strong>, i.e.,
determines the location and orientation of the joint axis, while
<span class="math notranslate nohighlight">\(X_i = X_\text{parent$(i)$} Q_i\)</span> is the <strong>joint output frame</strong>. In
a robot structure one typically has chains of alternating rigid and
parameterized transforms, e.g.,</p>
<p>a rigid transform <span class="math notranslate nohighlight">\(Q_{\pi(i)}\)</span> from world into the base of joint
<span class="math notranslate nohighlight">\(i\)</span></p>
<p>a parameterized transform <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span> representing the joint motion</p>
<p>a rigid transform <span class="math notranslate nohighlight">\(Q_{i \to \pi(j)}\)</span> from the output of <span class="math notranslate nohighlight">\(i\)</span>
into the base of a following joint <span class="math notranslate nohighlight">\(j\)</span></p>
<p>a parameterized transform <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span></p>
<p>etc</p>
<p>There is a minimalistic convention of describing robot structures,
called Denavit-Hartenberg convention. These describe the rigid
transformations between joints using only 4 numbers instead of 6 (which
pre-determines the zero calibration as well as the “lateral” positioning
of the following joint base frame). But there is no need to use this
convention and the above notation is conceptually cleaner and leads to
intuitive, freely user-defined joint base frames.</p>
<p>Let’s make our <code class="docutils literal notranslate"><span class="pre">mini.g</span></code> scene a robot:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">:</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span> <span class="s2">&quot;t(1 0 1) d(30 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.5</span><span class="p">]</span> <span class="p">}</span>
<span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span> <span class="p">{</span> <span class="n">joint</span><span class="p">:</span> <span class="n">hingeX</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;t(-1 0 1) d(90 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">]</span> <span class="p">}</span>
<span class="n">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span> <span class="p">{</span> <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;t(0 0 .5) d(30 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">],</span> <span class="n">color</span><span class="p">:[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Frame <span class="math notranslate nohighlight">\(B\)</span> became a joint. Note that <span class="math notranslate nohighlight">\(A\)</span> is the joint base
frame that determines its location and orientation, <span class="math notranslate nohighlight">\(B\)</span> is the
joint (output) frame, and <span class="math notranslate nohighlight">\(C\)</span> is a down-stream frame attached to
<span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>If you use <code class="docutils literal notranslate"><span class="pre">watchFile</span></code> and hit ENTER, the configuration is animated so
that the joint is articulated between its limits. In our case this leads
to a strange effect, uncovering an issue with our scene description:
Frame <span class="math notranslate nohighlight">\(B\)</span> is specified with a relative transform <span class="math notranslate nohighlight">\(Q\)</span> that
includes a translation; but it is also specified as <code class="docutils literal notranslate"><span class="pre">hingeX</span></code> joint
which can only generate rotations about <span class="math notranslate nohighlight">\(x\)</span>. The two
specifications are inconsistent and we should remove the direct
<span class="math notranslate nohighlight">\(Q\)</span> specification:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">:</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span> <span class="s2">&quot;t(1 0 1) d(30 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.5</span><span class="p">]</span> <span class="p">}</span>
<span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">):</span> <span class="p">{</span> <span class="n">joint</span><span class="p">:</span><span class="n">hingeX</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">limits</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">]</span> <span class="p">}</span>
<span class="n">C</span><span class="p">(</span><span class="n">B</span><span class="p">):</span> <span class="p">{</span> <span class="n">Q</span><span class="p">:</span> <span class="s2">&quot;t(0 0 .5) d(30 1 0 0)&quot;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">marker</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="p">[</span><span class="mf">.3</span><span class="p">],</span> <span class="n">color</span><span class="p">:[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>Here we also specified an initial joint angle <span class="math notranslate nohighlight">\(q=0.5\)</span> for the
hinge joint, as well as limits.</p>
</section>
<section id="configuration-joint-vector">
<h3>Configuration &amp; Joint Vector<a class="headerlink" href="#configuration-joint-vector" title="Permalink to this heading"></a></h3>
<p>We use the word <strong>configuration</strong> for an “articulated scene”, i.e.,
where some relative transforms <span class="math notranslate nohighlight">\(Q_i(q_i)\)</span> are parameterized by
dofs <span class="math notranslate nohighlight">\(q_i \in {\mathbb{R}}^{d_i}\)</span> (and also other dofs such as
forces or timings might be represented). A configuration can include
multiple robots – from our perspective there is no difference between
one or multiple robots. It’s just a parameterized forest of frames.</p>
<p>We define the <strong>joint vector</strong> <span class="math notranslate nohighlight">\(q\in{\mathbb{R}}^n\)</span> to be the
stacking of all dofs <span class="math notranslate nohighlight">\(q_i\)</span> (all dofs of a configuration). Given
the joint vector, we can forward chain all relative transformations in
the scene and thereby compute the absolute pose <span class="math notranslate nohighlight">\(X_i(q)\)</span> of every
frame as a function of <span class="math notranslate nohighlight">\(q\)</span>.</p>
</section>
<section id="forward-kinematics">
<h3>Forward Kinematics<a class="headerlink" href="#forward-kinematics" title="Permalink to this heading"></a></h3>
<p>This function <span class="math notranslate nohighlight">\(q \mapsto X_i(q)\)</span> is the core of <strong>forward
kinematics</strong>. It describes how the joint vector <span class="math notranslate nohighlight">\(q\)</span> determines the
pose of all frames in the configuration.</p>
<p>The precise definition of the term <strong>forward kinematics</strong> varies across
textbooks. I find the most concise definition to be the mapping from all
dofs <span class="math notranslate nohighlight">\(q\)</span> to the full configuration state
<span class="math notranslate nohighlight">\(\{X_i(q)\}_{i=1}^m\)</span>, which so far we described in terms of all
frame poses. This definition is consistent with the formal description
of <em>kinematics</em> as the theory of possible motions of a system
configuration (see 1.15.2).</p>
<p>But in practice, the word forward kinematics is often used simply as the
mapping from <span class="math notranslate nohighlight">\(q\)</span> to one particular “feature” of the configuration.
For instance, if <span class="math notranslate nohighlight">\(X_i(q)=(t_i(q),r_i(q))\)</span> is the pose of some
frame <span class="math notranslate nohighlight">\(i\)</span>, forward kinematics can describe the mapping</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(q\mapsto t_i(q)\)</span>   to the position of frame <span class="math notranslate nohighlight">\(i\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(q\mapsto r_i(q) \textbf{e}_x\)</span>   to the <span class="math notranslate nohighlight">\(x\)</span>-axis of frame
<span class="math notranslate nohighlight">\(i\)</span> (where <span class="math notranslate nohighlight">\(\textbf{e}_x = (1,0,0)^{\!\top\!}\)</span>).</p></li>
<li><p><span class="math notranslate nohighlight">\(q\mapsto X_i(q) p\)</span>   to the world coordinate a point attached
to frame <span class="math notranslate nohighlight">\(i\)</span> with fixed relative offset <span class="math notranslate nohighlight">\(p\)</span>.</p></li>
</ul>
<p>Each of these are 3-dimensional features. Let specifically focus on
three basic feature definitions</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
q \mapsto \phi^{\textsf{pos}}_{i,p}(q) &amp;= X_i(q)~ p \quad\in {\mathbb{R}}^3 ~, \\
q \mapsto \phi^{\textsf{vec}}_{i,v}(q) &amp;= r_i(q)~ v \quad\in {\mathbb{R}}^3 ~, \\
q \mapsto \phi^{\textsf{quat}}_{i}(q) &amp;= r_i(q) \quad\in {\mathbb{R}}^4 ~,\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi^{\textsf{pos}}_{i,p}(q)\)</span> is the (world) position of a
point attached to frame <span class="math notranslate nohighlight">\(i\)</span> with relative offset <span class="math notranslate nohighlight">\(p\)</span>,
<span class="math notranslate nohighlight">\(\phi^{\textsf{vec}}_{i,v}(q)\)</span> is the world coordinates of a
vector <span class="math notranslate nohighlight">\(v\)</span> attached to frame <span class="math notranslate nohighlight">\(i\)</span>, and
<span class="math notranslate nohighlight">\(\phi^{\textsf{quat}}_{i}(q)\)</span> is the 4D quaternion orientation of
frame <span class="math notranslate nohighlight">\(i\)</span>. From these three, many others features can be derived.</p>
<p>E.g., also the <span class="math notranslate nohighlight">\(3\times 3\)</span> rotation matrix is a useful basic
feature (as it is often used in equations). We can easily construct it
by concatenating columns, <span class="math notranslate nohighlight">\(\phi^{\textsf{rot}}_i =
(\phi^{\textsf{vec}}_{i,e_x}, \phi^{\textsf{vec}}_{i,e_y}, \phi^{\textsf{vec}}_{i,e_z}) \in {\mathbb{R}}^{3\times
3}\)</span> for basis vectors <span class="math notranslate nohighlight">\(e_x,e_y,e_z\)</span> of frame <span class="math notranslate nohighlight">\(i\)</span>. Note that
the Jacobian of this is a <span class="math notranslate nohighlight">\(3\times 3 \times n\)</span> tensor.</p>
<p>The output space of the kinematic map is also called <strong>task space</strong>.
However, I often just call it <strong>kinematic feature</strong>.</p>
<p>In our mini scene we can get and set the joint state, as well as query
the pose of all frames:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">getJointState</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

<span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">.5</span>
<span class="n">C</span><span class="o">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="n">C</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

<span class="n">frameC</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">frame</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pos:&#39;</span><span class="p">,</span> <span class="n">frameC</span><span class="o">.</span><span class="n">getPosition</span><span class="p">(),</span> <span class="s1">&#39;quat:&#39;</span><span class="p">,</span> <span class="n">frameC</span><span class="o">.</span><span class="n">getQuaternion</span><span class="p">())</span>

<span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">.5</span>
<span class="n">C</span><span class="o">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;pos:&#39;</span><span class="p">,</span> <span class="n">frameC</span><span class="o">.</span><span class="n">getPosition</span><span class="p">(),</span> <span class="s1">&#39;quat:&#39;</span><span class="p">,</span> <span class="n">frameC</span><span class="o">.</span><span class="n">getQuaternion</span><span class="p">())</span>
</pre></div>
</div>
<p>This example directly accesses a frame to query its position and
orientation. Frames can also be created and modified in this way.
However, below we introduce a more abstract way to access <em>features</em>
that is more consistent to how constraint problems are formulated.</p>
</section>
<section id="jacobians">
<h3>Jacobians<a class="headerlink" href="#jacobians" title="Permalink to this heading"></a></h3>
<p>We will use kinematic features <span class="math notranslate nohighlight">\(\phi\)</span> to formulate differentiable
constraint and optimization problem. Therefore, we assume all kinematic
features <span class="math notranslate nohighlight">\(\phi\)</span> are differentiable and we can efficiently compute
the <strong>Jacobian</strong></p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
J(q) = \frac{\partial}{\partial q}\phi(q) ~.\end{aligned}\]</div>
<p>If <span class="math notranslate nohighlight">\(y = \phi(q)\)</span>, then this Jacobian tells us how a velocity
<span class="math notranslate nohighlight">\(\dot q\)</span> in joint space implies a velocity <span class="math notranslate nohighlight">\(\dot y\)</span> in task
space,</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\dot y = J(q) \dot q ~.\end{aligned}\]</div>
<p>Recall that the forward kinematics is essentially implemented by forward
chaining the relative transforms <span class="math notranslate nohighlight">\(Q_i\)</span>. If we use an
auto-differentiable programming language for this, we’d directly have
the Jacobians. However, the Jacobians can also directly be expressed
analytically and their computation turns out simpler and more efficient
than the forward chaining itself. To implement a kinematic engine we
essentially need to figure out how the different joint types contribute
to the Jacobians of the three basic features above. This is covered by
considering the following cases:</p>
<section id="rotational-joint">
<h4>Rotational Joint<a class="headerlink" href="#rotational-joint" title="Permalink to this heading"></a></h4>
<p>Consider that somewhere on the path from world to frame <span class="math notranslate nohighlight">\(i\)</span> there
is a rotational (hinge) joint <span class="math notranslate nohighlight">\(j\)</span> positioned at <span class="math notranslate nohighlight">\(p_j\)</span> and
with unit axis vector <span class="math notranslate nohighlight">\(a_j\)</span> (both in world coordinates). Now
consider a point attached to frame <span class="math notranslate nohighlight">\(i\)</span> at world coordinate
<span class="math notranslate nohighlight">\(p\)</span>. (Note that we needed forward kinematics to determine
<span class="math notranslate nohighlight">\(p_j, a_j\)</span>, and <span class="math notranslate nohighlight">\(p\)</span>.) Then the velocity <span class="math notranslate nohighlight">\(\dot p\)</span>
relates to the joint angle velocity <span class="math notranslate nohighlight">\(\dot q_j\)</span> by</p>
<div class="math notranslate nohighlight">
\[\dot p = [a_j \times (p - p_j)]~ \dot q_j ~.\]</div>
<p>Now assume a vector <span class="math notranslate nohighlight">\(v\)</span> attached to frame <span class="math notranslate nohighlight">\(i\)</span>. Its velocity
is</p>
<div class="math notranslate nohighlight">
\[\dot v = [a_j \times v]~ \dot q_j = [-{\text{skew}}(v)~ a_j]~ \dot q_j ~.\]</div>
<p>Now consider the quaternion <span class="math notranslate nohighlight">\(r_i\)</span> of frame <span class="math notranslate nohighlight">\(i\)</span>. Its velocity
(much less obvious, see appendix Eq. ([eqQuatVel]))
is</p>
<div class="math notranslate nohighlight">
\[\dot r_i = {\frac{1}{2}}[(0,a_j)\circ r_i]~ \dot q_j ~.\]</div>
<p>Recall that <span class="math notranslate nohighlight">\(q\in{\mathbb{R}}^n\)</span> is the full joint vector. Let
<span class="math notranslate nohighlight">\(j\)</span> be the dof index of our rotational joint such that
<span class="math notranslate nohighlight">\(q_j \in {\mathbb{R}}\)</span> is the scalar joint angle. Further, let
<span class="math notranslate nohighlight">\(p_j,a_j\)</span> be the joint position and axis, and <span class="math notranslate nohighlight">\(p\)</span> a world
query point. We define two matrices that are zero except for the
provided columns:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
J^{\textsf{ang}}\in {\mathbb{R}}^{3 \times n} \quad\text{with}\quad &amp;J^{\textsf{ang}}_{:,j} = a_j ~, \\
J^{\textsf{pos}}(p) \in {\mathbb{R}}^{3 \times n} \quad\text{with}\quad &amp;J^{\textsf{pos}}_{:,j} = a_j \times (p - p_j) ~.\end{aligned}\end{split}\]</div>
<p>With these two matrices we can rewrite the above equations as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\dot p &amp;= J^{\textsf{pos}}(p)~ \dot q \\
\dot v &amp;= [-{\text{skew}}(v)~ J^{\textsf{ang}}(p)]~ \dot q \\
\dot r &amp;= {\frac{1}{2}}[\text{Skew}(r)~ \bar J^{\textsf{ang}}(p)]~ \dot q \quad\text{where}\quad \text{Skew}(w,x,y,z) =
 \left(\begin{array}{cccc}
   +w &amp; -x &amp; -y &amp; -z \\
   +x &amp; +w &amp; +z &amp; -y \\
   +y &amp; -z &amp; +w &amp; +x \\
   +z &amp; +y &amp; -x &amp; +w\end{array}\right)  ~, \label{eqQuatRate}\end{aligned}\end{split}\]</div>
<p>where by convention the cross-product <span class="math notranslate nohighlight">\([A\times v]\)</span> for a
<span class="math notranslate nohighlight">\(3\times n\)</span> matrix with a 3-vector takes the cross-products
<em>row-wise</em> (could perhaps better be written <span class="math notranslate nohighlight">\([-v\times A]\)</span>). The
last equation is derived in the appendix with
Eq. ([eqQuatVel]), where we discuss how an angular
velocity translates to a quaternion velocity. The bar in
<span class="math notranslate nohighlight">\(\bar J^{\textsf{ang}}\)</span> makes this a <span class="math notranslate nohighlight">\(4\times n\)</span> matrix by
inserting a zero top row (analogous to <span class="math notranslate nohighlight">\((0,w)\)</span> in
([eqQuatVel])). The <span class="math notranslate nohighlight">\(\text{Skew}\)</span> is an unusual
definition of a skew matrix for quaternions, so that quaternion
multiplication <span class="math notranslate nohighlight">\(a \circ b\)</span> can be written linearly as
<span class="math notranslate nohighlight">\(\text{Skew}(b)~ a\)</span>.</p>
<p>Now, if in our scene tree we have more than one rotational joint between
world and frame <span class="math notranslate nohighlight">\(i\)</span>, each of these joints simply contribute
non-zero columns to our basic matrices
<span class="math notranslate nohighlight">\(J^{\textsf{ang}}, J^{\textsf{pos}}(p)\)</span>. So this is the core of
what we have to implement for rotational joints.</p>
</section>
<section id="translational-joint">
<h4>Translational Joint<a class="headerlink" href="#translational-joint" title="Permalink to this heading"></a></h4>
<p>A translational (prismatic) joint on the path from world to frame
<span class="math notranslate nohighlight">\(i\)</span> also contribute a column to the basic matrix
<span class="math notranslate nohighlight">\(J^{\textsf{pos}}(p)\)</span>, but contributes notion to
<span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span> (as it does not imply rotational velocity in
the sub-branch). Specifically, let <span class="math notranslate nohighlight">\(a_j\)</span> the translational axis of
the joint with dof index <span class="math notranslate nohighlight">\(j\)</span>, then it simply contributes a column</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
J^{\textsf{pos}}_{:,j} = a_j ~.\end{aligned}\]</div>
<p>That’s it for translational joints.</p>
</section>
<section id="quaternion-joint">
<h4>Quaternion Joint<a class="headerlink" href="#quaternion-joint" title="Permalink to this heading"></a></h4>
<p>Trickier, but important for ball and free joints is to also know how a
quaternion joint contributes columns to <span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span> and
<span class="math notranslate nohighlight">\(J^{\textsf{pos}}(p)\)</span>. Modifying a quaternion parameterization
<span class="math notranslate nohighlight">\(q_j\in{\mathbb{R}}^4\)</span> of a relative transform <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span>
implies in some way a rotational velocity down the branch. So the effect
should be similar to a rotational joint, but without fixed axis and
modulated by the normalization of <span class="math notranslate nohighlight">\(q_j\)</span>. The solution is derived
in the appendix with Eq. ([eqQuatJac]) and summarized
here: Let <span class="math notranslate nohighlight">\(X_j\)</span> be the <em>output</em> pose of the quaternion joint.
(Yes, output!) And let <span class="math notranslate nohighlight">\(R_j\)</span> be the <span class="math notranslate nohighlight">\(3\times 3\)</span> rotation
matrix for the world pose <span class="math notranslate nohighlight">\(X_j\)</span>, and let
<span class="math notranslate nohighlight">\(r_j \in {\mathbb{R}}^4\)</span> be the quaternion of the <em>relative</em> joint
transform <span class="math notranslate nohighlight">\(Q_j\)</span>. Then</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuatJoint1}
J^{\textsf{ang}}_{:,j} = \frac{1}{|q|} R_j J(r_j) ~,\quad\text{where}\quad
J(r)_{:,k} &amp;= -2 (e_k \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})_{1:3} ~.\end{aligned}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(e_i\)</span> for <span class="math notranslate nohighlight">\(k=0,..,3\)</span> are the unit quaternions and the
matrix <span class="math notranslate nohighlight">\(J(r)\in{\mathbb{R}}{3 \times 4}\)</span> describes how a variation
of a quaternion <span class="math notranslate nohighlight">\(r\)</span> induces a 3D rotation vector relative to the
<em>output</em> space of <span class="math notranslate nohighlight">\(r\)</span>. I call this the quaternion Jacobian. The
derivation is found in the appendix when discussion how a quaternion
velocity implies and angular velocity. The multiplication with
<span class="math notranslate nohighlight">\(R_j\)</span> transforms this rotation vector to world coordinates. The
division by <span class="math notranslate nohighlight">\(|q_j|\)</span> accounts when the dof <span class="math notranslate nohighlight">\(q_j\)</span> is not
(exactly) normalized.</p>
<p>As we figured out the angular vector induced by a variation of a
quaternion joint, this also defines the column it contributes to the
positional Jacobian:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
J^{\textsf{pos}}_{:,j}(p) = [\frac{1}{|q|} R_j J(r_j)] \times (p - p_j) ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(p_j\)</span> is the position of the quaternion joint.</p>
<p>Note how differently we treat the quaternion <span class="math notranslate nohighlight">\(q_j\)</span> as a joint
parameterization <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span> and the quaternion <span class="math notranslate nohighlight">\(r_i\)</span> as a
kinematic (“output”) feature of frame <span class="math notranslate nohighlight">\(i\)</span>. For instance, we can
have the Jacobian of the quaternion <span class="math notranslate nohighlight">\(r_i\)</span> w.r.t. the quaternion
joint parameterization <span class="math notranslate nohighlight">\(q_j\)</span>, by inserting
([eqQuatJoint1]) into
([eqQuatRate]). And even if all other transformation
in the scene are identities and the output quaternion <span class="math notranslate nohighlight">\(r_i\)</span> is
“essentially identical” to the joint quaternion <span class="math notranslate nohighlight">\(q_j\)</span>, the
Jacobian is still not exactly identity, as it accounts for normalization
(and potential flip of sign).</p>
</section>
</section>
<section id="general-concept-of-differentiable-features">
<h3>General Concept of Differentiable Features<a class="headerlink" href="#general-concept-of-differentiable-features" title="Permalink to this heading"></a></h3>
<p>In the previous sections we focussed on the 3 mappings
<span class="math notranslate nohighlight">\(\phi^{\textsf{pos}}_{i,p}(q), \phi^{\textsf{vec}}_{i,v}(q), \phi^{\textsf{quat}}_{i}(q)\)</span>.
The Jacobians of these are given via <span class="math notranslate nohighlight">\(J^{\textsf{pos}}_{:,j}(p)\)</span>
and <span class="math notranslate nohighlight">\(J^{\textsf{ang}}_{:,j}(p)\)</span>. If these are given
(e.g. implemented by an efficient core kinematics engine), then many
other features can be computed based on them.</p>
<p>We assume a single configuration <span class="math notranslate nohighlight">\(q\)</span>, or a whole set of
configurations <span class="math notranslate nohighlight">\(\{q_1,..,q_T\}\)</span>, with each
<span class="math notranslate nohighlight">\(q_i \in\mathbb{R}\)</span> the DOFs of that configuration.</p>
<p>In general, a (0-order) <strong>feature</strong> <span class="math notranslate nohighlight">\(\phi\)</span> is a differentiable
mapping</p>
<div class="math notranslate nohighlight">
\[\phi: q \mapsto \mathbb{R}^D\]</div>
<p>of a single configuration into some <span class="math notranslate nohighlight">\(D\)</span>-dimensional space.</p>
<p>The rai code implements many features, most of them are accessible via a
feature symbol (FS). The Feature tutorial [&lt;notebooks/features.html&gt;]
should list all available features. New features can be implemented in
C++ by overloading the abstract Feature class.</p>
<p>When using features in code, one can additionally specify a <code class="docutils literal notranslate"><span class="pre">target</span></code>
and <code class="docutils literal notranslate"><span class="pre">scale</span></code>, to that the feature is transformed:</p>
<div class="math notranslate nohighlight">
\[\phi(q) \gets \texttt{scale} \cdot (\phi(q) - \texttt{target})\]</div>
<p>Note that the scale can be a matrix, which projects the feature. E.g.,
if you want to define a 2D feature which the <span class="math notranslate nohighlight">\(xy\)</span>-position of
frame <span class="math notranslate nohighlight">\(i\)</span>, then would could define use a matrix
<span class="math notranslate nohighlight">\(\texttt{scale}= \left(\begin{array}{ccc}1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0\end{array}\right)\)</span>.</p>
<p>Further, a feature can also be of higher order, which by default means a
finite difference of a 0-order features. In general, a higher-order
features is a differentiable mapping</p>
<div class="math notranslate nohighlight">
\[\phi: (q_0,q_1,..,q_k) \mapsto \mathbb{R}^D\]</div>
<p>of a <span class="math notranslate nohighlight">\((k+1)\)</span>-tuple of configurations to a <span class="math notranslate nohighlight">\(D\)</span>-dimensional
space.</p>
<p>Given any 0-order feature <span class="math notranslate nohighlight">\(\phi\)</span>, by default that defines its 1st
and 2st order feature as</p>
<div class="math notranslate nohighlight">
\[\phi(q_0,q_1) = \frac{1}{\tau}(\phi(q_1) - \phi(q_0))\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\phi(q_0,q_1,q_2) = \frac{1}{\tau^2}(\phi(q_2) - 2 \phi(q_1) + \phi(q_0)) ~,\]</div>
<p>which are the finite difference approximations of the feature’s velocity
and acceleration. However, one can also directly implement higher-order
features, e.g. to represent dynamics constraints, or more elaborate
acceleration/torque cost features.</p>
</section>
<section id="summary-implementing-a-kinematic-engine">
<h3>Summary: Implementing a Kinematic Engine<a class="headerlink" href="#summary-implementing-a-kinematic-engine" title="Permalink to this heading"></a></h3>
<p>The above provides all essentials necessary to implement a rather
general kinematic engine. To summarize:</p>
<ul class="simple">
<li><p>Represent a scene configuration as a tree of frames, where for each
frame we store the absolute pose <span class="math notranslate nohighlight">\(X\)</span> and relative transform
<span class="math notranslate nohighlight">\(Q\)</span>. We also annotate which relative transforms <span class="math notranslate nohighlight">\(Q\)</span> have
dofs and how many. We need to maintain an index mapping that tells us
which entries <span class="math notranslate nohighlight">\(q_j\)</span> of the full joint vector parameterize a
given relative transformation <span class="math notranslate nohighlight">\(Q_j(q_j)\)</span> (essentially mapping
between <span class="math notranslate nohighlight">\(q\)</span>-indices and frame indices).</p></li>
<li><p>An efficient implementation of forward chaining transformations:
Given the absolute poses <span class="math notranslate nohighlight">\(X\)</span> of all root frames and all
relative transforms <span class="math notranslate nohighlight">\(Q\)</span>, implement an efficient algorithm to
forward chain transformations to ensure any <span class="math notranslate nohighlight">\(X_i\)</span>. Do this
lazily on demand: Only when an absolute frame <span class="math notranslate nohighlight">\(X_i\)</span> is actually
queried call this forward chaining for this <span class="math notranslate nohighlight">\(X_i\)</span> only.</p></li>
<li><p>An efficient implementation of the matrices <span class="math notranslate nohighlight">\(J^{\textsf{pos}}\)</span>
and <span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span>, which, for any query frame <span class="math notranslate nohighlight">\(i\)</span>,
determines which joints are on the path from <span class="math notranslate nohighlight">\(i\)</span> to a root
frame and for each of these joints contributes the corresponding
columns to <span class="math notranslate nohighlight">\(J^{\textsf{pos}}\)</span> and <span class="math notranslate nohighlight">\(J^{\textsf{ang}}\)</span>. To
account for large systems (esp. path configurations, see below)
matrices should be returned in sparse format.</p></li>
</ul>
<p>Based on this, one provides more convenient user functions that allow to
query kinematic features for any frame <span class="math notranslate nohighlight">\(i\)</span>, including the pose
<span class="math notranslate nohighlight">\(X_i\)</span>, and on demand also provide the Jacobian of that feature.</p>
<p>Code tutorials: Code Tutorials: Configurations
[&lt;notebook/1a-configuration.ipynb&gt;], Features
[&lt;notebook/features.ipynb&gt;]</p>
</section>
<section id="inverse-kinematics">
<h3>Inverse Kinematics<a class="headerlink" href="#inverse-kinematics" title="Permalink to this heading"></a></h3>
<p><img alt="image" src="script/caption" /></p>
<p>We can “puppeteer” a robot by defining optimization problems with task
space constraints and solve for the joint state.</p>
<p>We introduced forward kinematics as a mapping from an
<span class="math notranslate nohighlight">\(n\)</span>-dimensional joint vector <span class="math notranslate nohighlight">\(q\in{\mathbb{R}}^n\)</span> to some
<span class="math notranslate nohighlight">\(d\)</span>-dimensional kinematic feature
<span class="math notranslate nohighlight">\(y=\phi(q) \in{\mathbb{R}}^d\)</span>. Inverse kinematics roughly means to
invert this mapping, i.e., given a desired target <span class="math notranslate nohighlight">\(y^*\)</span> in task
space, find a joint vector <span class="math notranslate nohighlight">\(q\)</span> such that <span class="math notranslate nohighlight">\(\phi(q) = y^*\)</span>. As
often <span class="math notranslate nohighlight">\(n&gt;d\)</span>, the inversion is under-specified (leading to what is
called “redundancy”). But just as the pseudo-inverse of linear
transformation addresses this, we can generalize this to a non-linear
<span class="math notranslate nohighlight">\(\phi\)</span> – namely in an optimality formulation.</p>
<p>Given <span class="math notranslate nohighlight">\(\phi\)</span> and a target <span class="math notranslate nohighlight">\(y^*\)</span>, a good option is to define
<strong>inverse kinematics</strong> as the non-linear mathematical program (NLP)</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqIKNLP}
q^* = \argmin_q f(q) ~~\text{s.t.}~~\phi(q) = y^* ~.\end{aligned}\]</div>
<p>The cost term <span class="math notranslate nohighlight">\(f(q)\)</span> is called <em>regularization</em> and indicates a
preference among all solutions that satisfy <span class="math notranslate nohighlight">\(\phi(q) = y\)</span>. One
might typically choose it as a squared distance
<span class="math notranslate nohighlight">\(f(q) = |\!|q-q_0|\!|^2_W\)</span> to some “default” <span class="math notranslate nohighlight">\(q_0\)</span>, which
could be the homing state of a robot or its current state.</p>
<p>In practice, I recommend always using a proper NLP solver to solve
inverse kinematics. As discussing optimization is beyond this script we
are here already done with describing inverse kinematics! It is “noting
more” than defining a constraint problem of the sort
([eqIKNLP]) and passing it to a solver. In the coding
part below I will discuss the richness in options to define such
constraint problems with our differentiable features.</p>
<p>Only for educational purpose we will also derive the classical
pseudo-inverse Jacobian solution to IK below.</p>
<section id="building-an-nlp-from-features">
<h4>Building an NLP from features<a class="headerlink" href="#building-an-nlp-from-features" title="Permalink to this heading"></a></h4>
<p>Eq. ([eqIKNLP]) describes IK as an NLP. Appendix
1.13.1 provides a technical reference of how we define
NLPs mathematically and in code. We summarize this here to enable us
defining IK problems in the next coding example. Essentially, we specify
an NLP by <em>adding objectives</em>, i.e., adding entries to the total feature
function <span class="math notranslate nohighlight">\(\phi(x)\)</span> and specifying the objective type:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\phi(x) =  \left(\begin{array}{c}f_1(x) \\ r_1(x) \\ h_1(x) \\ g_1(x) \\ h_2(x) \\ \vdots\end{array}\right)
~,\quad
\rho =  \left(\begin{array}{c}\texttt{f}\\ \texttt{sos}\\ \texttt{eq}\\ \texttt{ineq}\\ \texttt{eq}\\ \vdots\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>The indicator vector <span class="math notranslate nohighlight">\(\rho\)</span> informs the solver which components of
<span class="math notranslate nohighlight">\(\phi\)</span> have to be treated as cost, sos, eq, or ineq. The entries
“<span class="math notranslate nohighlight">\(f_1\)</span>, <span class="math notranslate nohighlight">\(r_1\)</span>,..” are any features defined in the same
convention as above. This defines an NLP of the form</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{b_l\le x \le b_u}~ {{\bf 1}}^{\!\top\!}\phi_\texttt{f}(x) + \phi_\texttt{sos}(x)^{\!\top\!}\phi_\texttt{sos}(x)
  ~~\text{s.t.}~~\phi_\texttt{ineq}(x) \le 0,~ \phi_\texttt{eq}(x) = 0 ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_\texttt{sos}\)</span> is the subsets of <code class="docutils literal notranslate"><span class="pre">sos</span></code>-features, etc.</p>
<p>Let’s use a more interesting scene configuration to demonstrate IK. This
is really a core exercise, as it opens up the space of defining
kinematic constraint problems.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="s1">&#39;~/git/rai-python/build&#39;</span><span class="p">))</span>
<span class="kn">import</span> <span class="nn">libry</span> <span class="k">as</span> <span class="nn">ry</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">ry</span><span class="o">.</span><span class="n">Config</span><span class="p">()</span>
<span class="n">C</span><span class="o">.</span><span class="n">addFile</span><span class="p">(</span><span class="n">ry</span><span class="o">.</span><span class="n">raiPath</span><span class="p">(</span><span class="s1">&#39;../rai-robotModels/scenarios/pandasTable.g&#39;</span><span class="p">))</span>
<span class="n">C</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

<span class="n">C</span><span class="o">.</span><span class="n">addFrame</span><span class="p">(</span><span class="s1">&#39;boxR&#39;</span><span class="p">,</span><span class="s1">&#39;table&#39;</span><span class="p">)</span> \
  <span class="o">.</span><span class="n">setRelativePosition</span><span class="p">([</span><span class="mf">.15</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">.1</span><span class="p">])</span> \
  <span class="o">.</span><span class="n">setShape</span><span class="p">(</span><span class="n">ry</span><span class="o">.</span><span class="n">ST</span><span class="o">.</span><span class="n">ssBox</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.02</span><span class="p">])</span> \
  <span class="o">.</span><span class="n">setColor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">addFrame</span><span class="p">(</span><span class="s1">&#39;boxL&#39;</span><span class="p">,</span><span class="s1">&#39;table&#39;</span><span class="p">)</span> \
  <span class="o">.</span><span class="n">setRelativePosition</span><span class="p">([</span><span class="o">-</span><span class="mf">.15</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">.1</span><span class="p">])</span> \
  <span class="o">.</span><span class="n">setShape</span><span class="p">(</span><span class="n">ry</span><span class="o">.</span><span class="n">ST</span><span class="o">.</span><span class="n">ssBox</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.1</span><span class="p">,</span><span class="mf">.02</span><span class="p">])</span> \
  <span class="o">.</span><span class="n">setColor</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mf">.5</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
</pre></div>
</div>
<p>So far, we just created a new scene, with a yellow and orange box. Now
let’s define an NLP and solve it: [pgIK]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">komo</span> <span class="o">=</span> <span class="n">ry</span><span class="o">.</span><span class="n">KOMO</span><span class="p">()</span>
<span class="n">komo</span><span class="o">.</span><span class="n">setConfig</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
<span class="n">komo</span><span class="o">.</span><span class="n">setTiming</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">5.</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">komo</span><span class="o">.</span><span class="n">addControlObjective</span><span class="p">([],</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">1e-1</span><span class="p">)</span>
<span class="n">komo</span><span class="o">.</span><span class="n">addObjective</span><span class="p">([],</span> <span class="n">ry</span><span class="o">.</span><span class="n">FS</span><span class="o">.</span><span class="n">accumulatedCollisions</span><span class="p">,</span> <span class="p">[],</span> <span class="n">ry</span><span class="o">.</span><span class="n">OT</span><span class="o">.</span><span class="n">eq</span><span class="p">);</span>
<span class="n">komo</span><span class="o">.</span><span class="n">addObjective</span><span class="p">([],</span> <span class="n">ry</span><span class="o">.</span><span class="n">FS</span><span class="o">.</span><span class="n">jointLimits</span><span class="p">,</span> <span class="p">[],</span> <span class="n">ry</span><span class="o">.</span><span class="n">OT</span><span class="o">.</span><span class="n">ineq</span><span class="p">);</span>
<span class="n">komo</span><span class="o">.</span><span class="n">addObjective</span><span class="p">([],</span> <span class="n">ry</span><span class="o">.</span><span class="n">FS</span><span class="o">.</span><span class="n">positionDiff</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;r_gripper&#39;</span><span class="p">,</span> <span class="s1">&#39;boxL&#39;</span><span class="p">],</span> <span class="n">ry</span><span class="o">.</span><span class="n">OT</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="mf">1e1</span><span class="p">]);</span>
<span class="n">komo</span><span class="o">.</span><span class="n">addObjective</span><span class="p">([],</span> <span class="n">ry</span><span class="o">.</span><span class="n">FS</span><span class="o">.</span><span class="n">positionDiff</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;l_gripper&#39;</span><span class="p">,</span> <span class="s1">&#39;boxR&#39;</span><span class="p">],</span> <span class="n">ry</span><span class="o">.</span><span class="n">OT</span><span class="o">.</span><span class="n">eq</span><span class="p">,</span> <span class="p">[</span><span class="mf">1e1</span><span class="p">]);</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">ry</span><span class="o">.</span><span class="n">NLP_Solver</span><span class="p">()</span> \
  <span class="o">.</span><span class="n">setProblem</span><span class="p">(</span><span class="n">komo</span><span class="o">.</span><span class="n">nlp</span><span class="p">())</span> \
  <span class="o">.</span><span class="n">setOptions</span><span class="p">(</span> <span class="n">stopTolerance</span><span class="o">=</span><span class="mf">1e-2</span> <span class="p">)</span> \
  <span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

<span class="n">komo</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;waypoint solution&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the first block, we define a KOMO object, which is nothing but an NLP
description over configurations. The <code class="docutils literal notranslate"><span class="pre">setConfig</span></code> and <code class="docutils literal notranslate"><span class="pre">setTiming</span></code>
calls state that we’re optimizing only over a single configuration, as
always in Inverse Kinematics. We’ll later explain how to optimize over
sequences of configurations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">add</span></code> methods add objectives (=cost terms, or eq, or ineq
constraints) to the NLP description. The <code class="docutils literal notranslate"><span class="pre">ControlObjective</span></code> is a
small-weighted regularization <span class="math notranslate nohighlight">\(|\!|q-q_0|\!|^2\)</span> to optimize for IK
solutions close to the starting configuration. The others add features
that define equality (<code class="docutils literal notranslate"><span class="pre">ry.OT.eq</span></code>) or inequality (<code class="docutils literal notranslate"><span class="pre">ry.OT.ineq</span></code>)
constraints in the NLP.</p>
<p>This <em>language</em> of adding objectives to an NLP description is at the
core of the robotics library we use. Here it is used to define an
Inverse Kinematics problem. Later we can use it to define path
optimization problems, as well as MPC (reactive control) problems.</p>
<p><code class="docutils literal notranslate"><span class="pre">NLP_Solver</span></code> is a generic NLP solver (by default using an Augmented
Lagrangian method) that we introduce in the Optimization Algorithms
Lecture. The <code class="docutils literal notranslate"><span class="pre">ret</span></code> tells us how many steps (<code class="docutils literal notranslate"><span class="pre">evals</span></code>) the solver
needed, and what the costs and constraint errors at convergence are.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">komo</span></code> display shows both, the initial configuration and the
solved configuration overlayed. With the following, we can read out the
optimal joint vector:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q</span> <span class="o">=</span> <span class="n">komo</span><span class="o">.</span><span class="n">getPath</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>

<span class="n">C</span><span class="o">.</span><span class="n">setJointState</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">C</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="classical-derivation-of-pseudo-inverse-jacobian-solution">
<h4>Classical Derivation of Pseudo-Inverse Jacobian Solution<a class="headerlink" href="#classical-derivation-of-pseudo-inverse-jacobian-solution" title="Permalink to this heading"></a></h4>
<p>I strongly recommend using an NLP solver and general constraint and cost
formulations to tackle IK problems – and you can skip over this section.
However, for completeness I provide here also the basic derivation of
classical pseudo-inverse Jacobian solutions.</p>
<section id="pseudo-inverse-jacobian">
<h5>Pseudo-inverse Jacobian.<a class="headerlink" href="#pseudo-inverse-jacobian" title="Permalink to this heading"></a></h5>
<p>We first simplify the problem to minimize</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqSoft}
f(q) = |\!|\phi(q) - y^*|\!|^2_C + |\!|q-q_0|\!|^2_W ~.\end{aligned}\]</div>
<p>Instead of exactly ensuring <span class="math notranslate nohighlight">\(\phi(q) = y^*\)</span>, this only minimizes a
penalty <span class="math notranslate nohighlight">\(|\!|\phi(q) - y^*|\!|^2_C\)</span>. Here <span class="math notranslate nohighlight">\(C\)</span> is the norm’s
metric, i.e., <span class="math notranslate nohighlight">\(|\!|v|\!|^2_C = v^{\!\top\!}C v\)</span>, but you may
instead simply assume <span class="math notranslate nohighlight">\(C\)</span> is a scalar. For finite <span class="math notranslate nohighlight">\(C\)</span> and
<span class="math notranslate nohighlight">\(W\)</span> this approximate formulation might be undesirable. But later
we will actually be able to investigate the limit <span class="math notranslate nohighlight">\(C\to\infty\)</span>.</p>
<p>Since this problem is a least squares problem, the canonical approach is
Gauss-Newton. The gradient, approximate Hessian, and Gauss-Newton step
are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial}{\partial q} f(q)
&amp;= 2 (\phi(q)-y^*)^{\!\top\!}C J + 2 (q-q_0)^{\!\top\!}W = {\nabla_{\!\!f}}(q)^{\!\top\!}\\
{\nabla_{\!\!f}^2}(q)
&amp;\approx 2 (J^{\!\top\!}C J + W) \\
\delta(q)
&amp;= - [{\nabla_{\!\!f}^2}(q)]^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} {\nabla_{\!\!f}}(q) = (J^{\!\top\!}C J + W)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} [J^{\!\top\!}C (\phi(q)-y^*) + W (q-q_0) ]\end{aligned}\end{split}\]</div>
<p>With some identities, this can be rewritten as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\delta(q)
&amp;= J^\sharp (y^* - \phi(q)) + (I - J^\sharp J)~ (q_0 - q) \label{eqIK} \\
J^\sharp
&amp;= (J^{\!\top\!}C J + W)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}C = W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}(J W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}+ C^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
 \text{(Woodbury identity)}\end{aligned}\end{split}\]</div>
<p>The matrix <span class="math notranslate nohighlight">\(J^\sharp\)</span> is also called (regularized) pseudo-inverse
of <span class="math notranslate nohighlight">\(J\)</span>. In its second form (RHS of Woodbury), we can take the hard
limit <span class="math notranslate nohighlight">\(C\to\infty\)</span>, where
<span class="math notranslate nohighlight">\(J^\sharp \to W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!}(J W^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} J^{\!\top\!})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>
or, for <span class="math notranslate nohighlight">\(W={\rm\bf I}\)</span>,
<span class="math notranslate nohighlight">\(J^\sharp \to J^{\!\top\!}(J J^{\!\top\!})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>.</p>
<p>Eq. ([eqIK]) says that, to jump to the (approx.)
Gauss-Newton optimum, we should make a step <span class="math notranslate nohighlight">\(\delta\)</span> in joint
space proportional to the error <span class="math notranslate nohighlight">\((y^*-\phi(q))\)</span> in task space, and
(optionally) combined with a homing step towards <span class="math notranslate nohighlight">\(q_0\)</span> projected
to the task null space via the projection <span class="math notranslate nohighlight">\((I - J^\sharp J)\)</span>.</p>
<p>Performing a single step <span class="math notranslate nohighlight">\(\delta\)</span> is approximate due to the
non-linearity of <span class="math notranslate nohighlight">\(\phi\)</span>. To solve inverse kinematics exactly we
have to iterate Gauss-Newton steps. If lucky, we can use full stepsizes
(<span class="math notranslate nohighlight">\(\alpha= 1\)</span> in the speak of line search) and iterate
<span class="math notranslate nohighlight">\(q_{k{{\hspace{-0.0pt}\textrm{+}\hspace{-0.5pt}}1}} \gets q_k + \delta(q_k)\)</span>
until convergence, and will have an exact IK solution. If <span class="math notranslate nohighlight">\(\phi\)</span>
is very non-linear, we may have to do line searches along the step
directions to ensure convergence. If <span class="math notranslate nohighlight">\(\phi\)</span> is non-convex, we may
converge to a local optimum that depends on the initialization.</p>
</section>
<section id="on-the-fly-ik">
<h5>On the fly IK.<a class="headerlink" href="#on-the-fly-ik" title="Permalink to this heading"></a></h5>
<p>Inverse kinematics is sometimes being used to generate robot motion on
the fly. In a sense, rather than letting an optimization algorithm find
an IK solution and then start moving the robot to it (we we’ll do it
below), you let the robot directly move (generate a smooth path) towards
an IK solution. This is heuristic, and I eventually don’t recommend it.
But it’s standard practice, so let’s mention it:</p>
<p>Let the robot be in state <span class="math notranslate nohighlight">\(q\)</span>, and we have a task space target
<span class="math notranslate nohighlight">\(y^*\)</span>. We may compute a desired robot motion</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\dot q = \alpha\Big[ J^\sharp (y^* - \phi(q)) + (I - J^\sharp J) (q_0 - q) \Big] ~.\end{aligned}\]</div>
<p>In a sense, this mimics performing (integrating over time) infinitesimal
Gauss-Newton steps towards the IK solution. Often the regularization
<span class="math notranslate nohighlight">\((I - J^\sharp J) (q_0 - q)\)</span> is also dropped, which is the same as
saying <span class="math notranslate nohighlight">\(q_0 = q\)</span>, i.e., you always set the homing state
<span class="math notranslate nohighlight">\(q_0\)</span> to be the current state <span class="math notranslate nohighlight">\(q\)</span>, adapting it on the fly.
Doing this, you will loose a precise definition of where you’ll
eventually converge to – and sometimes this leads to undesired <em>drift in
nullspace</em>. All not recommended.</p>
</section>
<section id="singularity">
<h5>Singularity.<a class="headerlink" href="#singularity" title="Permalink to this heading"></a></h5>
<p>The limit <span class="math notranslate nohighlight">\(C\to\infty\)</span> mentioned above is only robust when
<span class="math notranslate nohighlight">\(\det (J
J^{\!\top\!}) &gt; 0\)</span>, or equivalently, when <span class="math notranslate nohighlight">\(J\)</span> has full rank
(namely rank <span class="math notranslate nohighlight">\(d\)</span>). <span class="math notranslate nohighlight">\(J\)</span> is called singular otherwise, and the
pseudo inverse <span class="math notranslate nohighlight">\(J^\sharp\)</span> is ill-defined.</p>
<p>Intuitively this means that, in state <span class="math notranslate nohighlight">\(q\)</span>, certain task space
directions cannot be generated, i.e., no motion in these task space
directions is possible. A stretched arm that cannot extend further is a
typical example.</p>
<p>In the original NLP formulation, this corresponds to the case where
<span class="math notranslate nohighlight">\(\phi(q) = y^*\)</span> is simply infeasible, and a proper NLP-solver
should return this information.</p>
<p>The soft problem formulation ([eqSoft]), where <span class="math notranslate nohighlight">\(C\)</span>
is finite (not <span class="math notranslate nohighlight">\(\infty\)</span>) is one way to address a singularity: For
finite <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(J^\sharp\)</span> is well defined and defines steps
towards a optimal solution of the trade-off problem
([eqSoft]). This is also called <strong>regularized IK</strong> or
<strong>singularity-robust IK</strong>. But it only leads to an approximate IK
solution.</p>
</section>
</section>
</section>
</section>
<section id="placeholder">
<h2>Placeholder<a class="headerlink" href="#placeholder" title="Permalink to this heading"></a></h2>
<p>To come:</p>
<p>Spline Motion and Control Levels</p>
<p>Motion Planning: Path/Trajectory Optimization and Finding</p>
<p>Dynamics</p>
<p>Simulation</p>
<p>Control Theory &amp; MPC</p>
<p>skipping here: Mobile Robotics slides</p>
</section>
<section id="practical-control-pid-splines-tracking-layes-of-control">
<h2>Practical Control: PID, Splines, Tracking, &amp; Layes of Control<a class="headerlink" href="#practical-control-pid-splines-tracking-layes-of-control" title="Permalink to this heading"></a></h2>
<p>In section we introduce some basics to understand how robot control are
typically realized in practise. Later sections will introduce in more
detail general dynamics, control theory, trajectory optimization, and
MPC. This section will help to grasp basic notions such as what is
compliance vs. admittance and time-continuous tracking references.</p>
</section>
<section id="path-planning">
<h2>Path Planning<a class="headerlink" href="#path-planning" title="Permalink to this heading"></a></h2>
</section>
<section id="path-optimization-briefly">
<h2>Path Optimization – briefly<a class="headerlink" href="#path-optimization-briefly" title="Permalink to this heading"></a></h2>
</section>
<section id="mobile-robotics">
<h2>Mobile Robotics<a class="headerlink" href="#mobile-robotics" title="Permalink to this heading"></a></h2>
</section>
<section id="control-theory">
<h2>Control Theory<a class="headerlink" href="#control-theory" title="Permalink to this heading"></a></h2>
</section>
<section id="skipped-this-term-grasping-brief-intro">
<h2>SKIPPED THIS TERM – Grasping (brief intro)<a class="headerlink" href="#skipped-this-term-grasping-brief-intro" title="Permalink to this heading"></a></h2>
</section>
<section id="skipped-this-term-legged-locomotion-brief-intro">
<h2>SKIPPED THIS TERM – Legged Locomotion (brief intro)<a class="headerlink" href="#skipped-this-term-legged-locomotion-brief-intro" title="Permalink to this heading"></a></h2>
</section>
<section id="d-transformations-rotations-quaternions">
<span id="apptransforms"></span><h2>3D Transformations, Rotations, Quaternions<a class="headerlink" href="#d-transformations-rotations-quaternions" title="Permalink to this heading"></a></h2>
<section id="rotations">
<h3>Rotations<a class="headerlink" href="#rotations" title="Permalink to this heading"></a></h3>
<p>There are many ways to represent rotations in <span class="math notranslate nohighlight">\(SO(3)\)</span>. We restrict
ourselves to three basic ones: rotation matrix, rotation vector, and
quaternion. The rotation vector is also the most natural representation
for a “rotation velocity” (angular velocities). Euler angles or
raw-pitch-roll are an alternative, but they have singularities and I
don’t recommend using them in practice.</p>
<dl>
<dt>A rotation matrix</dt><dd><p>is a matrix <span class="math notranslate nohighlight">\(R\in{\mathbb{R}}^{3\times3}\)</span> which is orthonormal
(columns and rows are orthogonal unit vectors, implying determinant
1). While a <span class="math notranslate nohighlight">\(3\times3\)</span> matrix has 9 degrees of freedom (DoFs),
the constraint of orthogonality and determinant 1 constraints this:
The set of rotation matrices has only 3 DoFs (<span class="math notranslate nohighlight">\(\sim\)</span> the local
Lie algebra is 3-dim).</p>
<p>The application of <span class="math notranslate nohighlight">\(R\)</span> on a vector <span class="math notranslate nohighlight">\(x\)</span> is simply the
matrix-vector product <span class="math notranslate nohighlight">\(R x\)</span>.</p>
<p>Concatenation of two rotations <span class="math notranslate nohighlight">\(R_1\)</span> and <span class="math notranslate nohighlight">\(R_2\)</span> is the
normal matrix-matrix product <span class="math notranslate nohighlight">\(R_1 R_2\)</span>.</p>
<p>Inversion is the transpose,
<span class="math notranslate nohighlight">\(R^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} = R^{\!\top\!}\)</span>.</p>
</dd>
<dt>A rotation vector</dt><dd><p>is an unconstrained vector <span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span>. The vector’s
direction <span class="math notranslate nohighlight">\(\underline w = \frac{w}{|w|}\)</span> determines the
rotation axis, the vector’s length <span class="math notranslate nohighlight">\(|w|=\theta\)</span> determines the
rotation angle (in radians, using the right thumb convention).</p>
<p>The application of a rotation described by <span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span>
on a vector <span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^3\)</span> is given as (Rodrigues’
formula)</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
w \cdot x
 &amp;= \cos\theta~ x
  + \sin\theta~ (\underline w\times x)
  + (1-\cos\theta)~ \underline w(\underline w^{\!\top\!}x)\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\theta=|w|\)</span> is the rotation angle and
<span class="math notranslate nohighlight">\(\underline w=w/\theta\)</span> the unit length rotation axis.</p>
<p>The inverse rotation is described by the negative of the rotation
vector.</p>
<p>Concatenation is non-trivial in this representation and we don’t
discuss it here. In practice, a rotation vector is first converted to
a rotation matrix or quaternion.</p>
<p>Conversion to a matrix: For every vector <span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span>
we define its skew symmetric matrix as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\hat w = \text{skew}(w) =  \left(\begin{array}{ccc}0 &amp; -w_3 &amp; w_2 \\ w_3 &amp; 0 &amp; -w_1 \\-w_2 &amp; w_1 &amp; 0\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Note that such skew-symmetric matrices are related to the cross
product: <span class="math notranslate nohighlight">\(w \times v = \hat w~ v\)</span>, where the cross product is
rewritten as a matrix product. The rotation matrix <span class="math notranslate nohighlight">\(R(w)\)</span> that
corresponds to a given rotation vector <span class="math notranslate nohighlight">\(w\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\label{eqRodriguez}
R(w)
 &amp;= \exp(\hat w) \\
 &amp;= \cos\theta~ I + \sin\theta~ \hat w/\theta+ (1-\cos\theta)~ w w^{\!\top\!}/\theta^2\end{aligned}\end{split}\]</div>
<p>The <span class="math notranslate nohighlight">\(\exp\)</span> function is called exponential map (generating a
group element (=rotation matrix) via an element of the Lie algebra
(=skew matrix)). The other equation is called Rodrigues’ equation:
the first term is a diagonal matrix (<span class="math notranslate nohighlight">\(I\)</span> is the 3D identity
matrix), the second terms the skew symmetric part, the last term the
symmetric part (<span class="math notranslate nohighlight">\(w
w^{\!\top\!}\)</span> is also called outer product).</p>
</dd>
<dt>Angular velocity &amp; derivative of a rotation matrix:</dt><dd><p>We represent angular velocities by a vector
<span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span>, the direction <span class="math notranslate nohighlight">\(\underline w\)</span>
determines the rotation axis, the length <span class="math notranslate nohighlight">\(|w|\)</span> is the rotation
velocity (in radians per second). When a body’s orientation at time
<span class="math notranslate nohighlight">\(t\)</span> is described by a rotation matrix <span class="math notranslate nohighlight">\(R(t)\)</span> and the
body’s angular velocity is <span class="math notranslate nohighlight">\(w\)</span>, then</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqDotR}
\dot R(t) = \hat w~ R(t)~.\end{aligned}\]</div>
<p>(That’s intuitive to see for a rotation about the <span class="math notranslate nohighlight">\(x\)</span>-axis with
velocity 1.) Some insights from this relation: Since <span class="math notranslate nohighlight">\(R(t)\)</span>
must always be a rotation matrix (fulfill orthogonality and
determinant 1), its derivative <span class="math notranslate nohighlight">\(\dot R(t)\)</span> must also fulfill
certain constraints; in particular it can only live in a
3-dimensional sub-space. It turns out that the derivative
<span class="math notranslate nohighlight">\(\dot R\)</span> of a rotation matrix <span class="math notranslate nohighlight">\(R\)</span> must always be a skew
symmetric matrix <span class="math notranslate nohighlight">\(\hat w\)</span> times <span class="math notranslate nohighlight">\(R\)</span> – anything else would
be inconsistent with the constraints of orthogonality and determinant
1.</p>
<p>Note also that, assuming <span class="math notranslate nohighlight">\(R(0)=I\)</span>, the solution to the
differential equation <span class="math notranslate nohighlight">\(\dot R(t) = \hat w~ R(t)\)</span> can be written
as <span class="math notranslate nohighlight">\(R(t)=\exp(t \hat w)\)</span>, where here the exponential function
notation is used to denote a more general so-called exponential map,
as used in the context of Lie groups. It also follows that
<span class="math notranslate nohighlight">\(R(w)\)</span> from ([eqRodriguez]) is the rotation
matrix you get when you rotate for 1 second with angular velocity
described by <span class="math notranslate nohighlight">\(w\)</span>.</p>
</dd>
<dt>Quaternion</dt><dd><p>(I’m not describing the general definition, only the “quaternion to
represent rotation” definition.) A quaternion is a unit length 4D
vector <span class="math notranslate nohighlight">\(r\in{\mathbb{R}}^4\)</span>; the first entry <span class="math notranslate nohighlight">\(r_0\)</span> is
related to the rotation angle <span class="math notranslate nohighlight">\(\theta\)</span> via
<span class="math notranslate nohighlight">\(r_0=\cos(\theta/2)\)</span>, the last three entries
<span class="math notranslate nohighlight">\(\bar r\equiv r_{1:3}\)</span> are related to the unit length rotation
axis <span class="math notranslate nohighlight">\(\underline w\)</span> via
<span class="math notranslate nohighlight">\(\bar r = \sin(\theta/2)~ \underline w\)</span>.</p>
<p>The inverse of a quaternion is given by negating <span class="math notranslate nohighlight">\(\bar r\)</span>,
<span class="math notranslate nohighlight">\(r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} =
(r_0,-\bar r)\)</span> (or, alternatively, negating <span class="math notranslate nohighlight">\(r_0\)</span>).</p>
<p>The concatenation of two rotations <span class="math notranslate nohighlight">\(r\)</span>, <span class="math notranslate nohighlight">\(r'\)</span> is given as
the quaternion product</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuat}
r \circ r'
 = (r_0 r'_0 - \bar r^{\!\top\!}\bar r',~
    r_0 \bar r' + r'_0 \bar r + \bar r' \times \bar r)\end{aligned}\]</div>
<p>The application of a rotation quaternion <span class="math notranslate nohighlight">\(r\)</span> on a vector
<span class="math notranslate nohighlight">\(x\)</span> can be expressed by converting the vector first to the
quaternion <span class="math notranslate nohighlight">\((0,x)\)</span>, then computing</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
r \cdot x = (r \circ (0,x) \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})_{1:3} ~,\end{aligned}\]</div>
<p>I think a bit more efficient is to first convert the rotation
quaternion <span class="math notranslate nohighlight">\(r\)</span> to the equivalent rotation matrix <span class="math notranslate nohighlight">\(R\)</span>, as
given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
R
 &amp;=  \left(\begin{array}{ccc}
    1-r_{22}-r_{33} &amp; r_{12}-r_{03} &amp;    r_{13}+r_{02} \\
    r_{12}+r_{03} &amp;   1-r_{11}-r_{33} &amp;  r_{23}-r_{01} \\
    r_{13}-r_{02} &amp;   r_{23}+r_{01} &amp;    1-r_{11}-r_{22}
    \end{array}\right)  \\ &amp; ~ r_{ij} := 2 r_i r_j ~.\end{aligned}\end{split}\]</div>
<p>(Note: In comparison to ([eqRodriguez]) this does
not require to compute a <span class="math notranslate nohighlight">\(\sin\)</span> or <span class="math notranslate nohighlight">\(\cos\)</span>.) Inversely,
the quaternion <span class="math notranslate nohighlight">\(r\)</span> for a given matrix <span class="math notranslate nohighlight">\(R\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    r_0 &amp;= {\frac{1}{2}}\sqrt{1+{\rm tr}R}\\
    r_3 &amp;= (R_{21}-R_{12})/(4 r_0)\\
    r_2 &amp;= (R_{13}-R_{31})/(4 r_0)\\
    r_1 &amp;= (R_{32}-R_{23})/(4 r_0) ~.\end{aligned}\end{split}\]</div>
</dd>
<dt>Angular velocity <span class="math notranslate nohighlight">\(\to\)</span> quaternion velocity</dt><dd><p>Given an angular velocity <span class="math notranslate nohighlight">\(w\in{\mathbb{R}}^3\)</span> and a current
quaternion <span class="math notranslate nohighlight">\(r(t)\in{\mathbb{R}}\)</span>, what is the time derivative
<span class="math notranslate nohighlight">\(\dot r(t)\)</span> (in analogy to Eq. ([eqDotR]))? For
simplicity, let’s first assume <span class="math notranslate nohighlight">\(|w|=1\)</span>. For a small time
interval <span class="math notranslate nohighlight">\(\delta\)</span>, <span class="math notranslate nohighlight">\(w\)</span> generates a rotation vector
<span class="math notranslate nohighlight">\(\delta w\)</span>, which converts to a quaternion</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\Delta r = (\cos(\delta/2), \sin(\delta/2) w) ~.\end{aligned}\]</div>
<p>That rotation is concatenated LHS to the original quaternion,</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
r(t+\delta)
 = \Delta r \circ r(t) ~.\end{aligned}\]</div>
<p>Now, if we take the derivative w.r.t. <span class="math notranslate nohighlight">\(\delta\)</span> and evaluate
it at <span class="math notranslate nohighlight">\(\delta=0\)</span>, all the <span class="math notranslate nohighlight">\(\cos(\delta/2)\)</span> terms become
<span class="math notranslate nohighlight">\(-\sin(\delta/2)\)</span> and evaluate to zero, all the
<span class="math notranslate nohighlight">\(\sin(\delta/2)\)</span> terms become <span class="math notranslate nohighlight">\(\cos(\delta/2)\)</span> and
evaluate to one, and we have</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuatVel}
\dot r(t)
&amp;= {\frac{1}{2}}( - w^{\!\top\!}\bar r,~  r_0 w + \bar r \times w )
 = {\frac{1}{2}}(0,w) \circ r(t)\end{aligned}\]</div>
<p>Here <span class="math notranslate nohighlight">\((0,w)\in{\mathbb{R}}^4\)</span> is a four-vector; for
<span class="math notranslate nohighlight">\(|w|=1\)</span> it is a normalized quaternion. However, due to the
linearity the equation holds for any <span class="math notranslate nohighlight">\(w\)</span>.</p>
</dd>
<dt>Quaternion velocity <span class="math notranslate nohighlight">\(\to\)</span> angular velocity</dt><dd><p>The following is relevant when taking the derivative w.r.t. the
quaternion parameters, e.g., for a ball joint represented as
quaternion. Given <span class="math notranslate nohighlight">\(\dot r\)</span>, we have</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\dot r \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
&amp;= {\frac{1}{2}}(0,w) \circ r \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} = {\frac{1}{2}}(0,w) ~,\quad w = 2~ [\dot r \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}]_{1:3}\end{aligned}\]</div>
<p>which allows us to read off the angular velocity <span class="math notranslate nohighlight">\(w\)</span> induced by
a change of quaternion <span class="math notranslate nohighlight">\(\dot r\)</span>. However, the RHS zero will
hold true only iff <span class="math notranslate nohighlight">\(\dot
r\)</span> is orthogonal to <span class="math notranslate nohighlight">\(r\)</span> (where
<span class="math notranslate nohighlight">\(\dot r^{\!\top\!}r = \dot r_0 r_0 + \dot {\bar
r^{\!\top\!}} \bar r = 0\)</span>, see ). In case
<span class="math notranslate nohighlight">\(\dot r^{\!\top\!}r \not=0\)</span>, the change in length of the
quaternion does not represent any angular velocity; in typical
kinematics engines a non-unit length is ignored. Therefore one first
orthogonalizes <span class="math notranslate nohighlight">\(\dot
r \gets \dot r - r(\dot r^{\!\top\!}r)\)</span>.</p>
<p>As a special case of application, consider computing the partial
derivative w.r.t. quaternion parameters, where <span class="math notranslate nohighlight">\(\dot r\)</span> is the
4D unit vectors <span class="math notranslate nohighlight">\(e_0,..,e_3\)</span>. In this case, the
orthogonalization becomes simply <span class="math notranslate nohighlight">\(e_i \gets e_i - r r_i\)</span> and</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
(e_i - r_i r) \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
&amp;= e_i \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} - r_i (1,0,0,0) \\
w_i
&amp;= 2~ [e_i \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}]_{1:3} ~,\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(w_i\)</span> is the rotation vector implied by
<span class="math notranslate nohighlight">\(\dot r = e_i\)</span>. In case the original quaternion <span class="math notranslate nohighlight">\(r\)</span>
wasn’t normalized (which could be, if a standard optimization
algorithm searches in the quaternion parameter space), then <span class="math notranslate nohighlight">\(r\)</span>
actually represents the normalized quaternion
<span class="math notranslate nohighlight">\(\bar r = \frac{1}{\sqrt{r^2}} r\)</span>, and (due to linearity of the
above), the rotation vector implied by <span class="math notranslate nohighlight">\(\dot r = e_i\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\label{eqQuatJac}
w_i
&amp;= \frac{2}{\sqrt{r^2}}~ [e_i \circ r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}]_{1:3} ~.\end{aligned}\]</div>
<p>This defines a <span class="math notranslate nohighlight">\(3\times 4\)</span> <strong>quaternion Jacobian</strong>
<span class="math notranslate nohighlight">\(J_{:i} = w_i\)</span> with 4 columns <span class="math notranslate nohighlight">\(w_i\)</span>, so that
<span class="math notranslate nohighlight">\(w = J \dot r\)</span> is the angular velocity induced by a quaternion
velocity <span class="math notranslate nohighlight">\(\dot r\)</span> (accounting for all implicit normalizations).</p>
</dd>
</dl>
</section>
<section id="transformations-1">
<span id="id1"></span><h3>Transformations<a class="headerlink" href="#transformations-1" title="Permalink to this heading"></a></h3>
<p>We consider two types of transformations here: either static
(translation+rotation), or dynamic
(translation+velocity+rotation+angular velocity). The first maps between
two static reference frames, the latter between moving reference frames,
e.g. between reference frames attached to moving rigid bodies.</p>
<section id="static-transformations">
<h4>Static transformations<a class="headerlink" href="#static-transformations" title="Permalink to this heading"></a></h4>
<p>Concerning the static transformations, again there are different
representations:</p>
<dl>
<dt>A homogeneous matrix</dt><dd><p>is a <span class="math notranslate nohighlight">\(4\times 4\)</span>-matrix of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
T =  \left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right) \end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(R\)</span> is a <span class="math notranslate nohighlight">\(3\times 3\)</span>-matrix (rotation in our case)
and <span class="math notranslate nohighlight">\(t\)</span> a <span class="math notranslate nohighlight">\(3\)</span>-vector (translation).</p>
<p>In homogeneous coordinates, vectors <span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^3\)</span> are
expanded to 4D vectors
<span class="math notranslate nohighlight">\(\left(\begin{array}{c}x\\1\end{array}\right)  \in {\mathbb{R}}^4\)</span>
by appending a 1.</p>
<p>Application of a transform <span class="math notranslate nohighlight">\(T\)</span> on a vector
<span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^3\)</span> is then given as the normal matrix-vector
product</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
x' = T \cdot x
 &amp;= T~  \left(\begin{array}{c}x \\ 1\end{array}\right)
  =  \left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right) ~  \left(\begin{array}{c}x \\ 1\end{array}\right)
  =  \left(\begin{array}{c}Rx + t \\ 1\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Concatenation is given by the ordinary 4-dim matrix-matrix product.</p>
<p>The inverse transform is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
 &amp;=  \left(\begin{array}{cc}R &amp; t \\ 0 &amp; 1\end{array}\right) ^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}
  =  \left(\begin{array}{cc}R^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} &amp; -R^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} t \\ 0 &amp; 1\end{array}\right) \end{aligned}\end{split}\]</div>
</dd>
<dt>Translation and quaternion:</dt><dd><p>A transformation can efficiently be stored as a pair <span class="math notranslate nohighlight">\((t,r)\)</span> of
a translation vector <span class="math notranslate nohighlight">\(t\)</span> and a rotation quaternion <span class="math notranslate nohighlight">\(r\)</span>.
Analogous to the above, the application of <span class="math notranslate nohighlight">\((t,r)\)</span> on a vector
<span class="math notranslate nohighlight">\(x\)</span> is <span class="math notranslate nohighlight">\(x' = t + r\cdot x\)</span>; the inverse is
<span class="math notranslate nohighlight">\((t,r)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} = (-r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\cdot t, r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1})\)</span>;
the concatenation is
<span class="math notranslate nohighlight">\((t_1,r_1) \circ (t_2,r_2) = (t_1 + r_1\cdot t_2, r_1 \circ r_2)\)</span>.</p>
</dd>
</dl>
</section>
<section id="dynamic-transformations">
<h4>Dynamic transformations<a class="headerlink" href="#dynamic-transformations" title="Permalink to this heading"></a></h4>
<p>Just as static transformations map between (static) coordinate frames,
dynamic transformations map between moving (inertial) frames which are,
e.g., attached to moving bodies. A dynamic transformation is described
by a tuple <span class="math notranslate nohighlight">\((t,r,v,w)\)</span> with translation <span class="math notranslate nohighlight">\(t\)</span>, rotation
<span class="math notranslate nohighlight">\(r\)</span>, velocity <span class="math notranslate nohighlight">\(v\)</span> and angular velocity <span class="math notranslate nohighlight">\(w\)</span>. Under a
dynamic transform <span class="math notranslate nohighlight">\((t,r,v,w)\)</span> a position and velocity
<span class="math notranslate nohighlight">\((x,\dot x)\)</span> maps to a new position and velocity
<span class="math notranslate nohighlight">\((x',\dot x')\)</span> given as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp; x'=t + r\cdot x \\
&amp; \dot x' = v + w \times (r\cdot x)+ r\cdot\dot x\end{aligned}\end{split}\]</div>
<p>(the second term is the additional linear velocity of <span class="math notranslate nohighlight">\(\dot x'\)</span>
arising from the angular velocity <span class="math notranslate nohighlight">\(w\)</span> of the dynamic transform).
The concatenation
<span class="math notranslate nohighlight">\((t,r,v,w) = (t_1,r_1,v_1,w_1) \circ (t_2,r_2,v_2,w_2)\)</span> of two
dynamic transforms is given as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp; t = t_1 + r_1 \cdot t_2 \\
&amp; v = v_1 + w_1 \times (r_1 \cdot t_2) + r_1 \cdot v_2 \\
&amp; r = r_1 \circ r_2 \\
&amp; w = w_1 + r_1 \cdot w_2\end{aligned}\end{split}\]</div>
<p>For completeness, the footnote <a class="footnote-reference brackets" href="#id5" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> also describes how accelerations
transform, including the case when the transform itself is accelerating.
The inverse
<span class="math notranslate nohighlight">\((t',r',v',w') = (t,r,v,w)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>
of a dynamic transform is given as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp; t' = -r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} \cdot t \\
&amp; r' =  r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} \\
&amp; v' =  r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} \cdot (w \times t - v) \\
&amp; w' = -r^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} \cdot w\end{aligned}\end{split}\]</div>
<dl>
<dt>Sequences of transformations</dt><dd><p>by <span class="math notranslate nohighlight">\(T_{A\to
B}\)</span> we denote the transformation from frame <span class="math notranslate nohighlight">\(A\)</span> to frame
<span class="math notranslate nohighlight">\(B\)</span>. The frames <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> can be thought of
coordinate frames (tuples of an offset (in an affine space) and three
local orthonormal basis vectors) attached to two bodies <span class="math notranslate nohighlight">\(A\)</span> and
<span class="math notranslate nohighlight">\(B\)</span>. It holds</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
T_{A\to C} = T_{A\to B} \circ T_{B\to C}\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\circ\)</span> is the concatenation described above. Let
<span class="math notranslate nohighlight">\(p\)</span> be a point (rigorously, in the affine space). We write
<span class="math notranslate nohighlight">\(p^A\)</span> for the coordinates of point <span class="math notranslate nohighlight">\(p\)</span> relative to frame
<span class="math notranslate nohighlight">\(A\)</span>; and <span class="math notranslate nohighlight">\(p^B\)</span> for the coordinates of point <span class="math notranslate nohighlight">\(p\)</span>
relative to frame <span class="math notranslate nohighlight">\(B\)</span>. It holds</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
p^A = T_{A\to B}~ p^B ~.\end{aligned}\]</div>
</dd>
</dl>
</section>
<section id="a-note-on-affine-coordinate-frames">
<h4>A note on affine coordinate frames<a class="headerlink" href="#a-note-on-affine-coordinate-frames" title="Permalink to this heading"></a></h4>
<p>Instead of the notation <span class="math notranslate nohighlight">\(T_{A\to B}\)</span>, other text books often use
notations such as <span class="math notranslate nohighlight">\(T_{AB}\)</span> or <span class="math notranslate nohighlight">\(T^A_B\)</span>. A common question
regarding notation <span class="math notranslate nohighlight">\(T_{A\to B}\)</span> is the following:</p>
<blockquote>
<div><p><em>The notation :math:`T_{Ato B}` is confusing, since it transforms
coordinates from frame :math:`B` to frame :math:`A`. Why not the
other way around?</em></p>
</div></blockquote>
<p>I think the notation <span class="math notranslate nohighlight">\(T_{A\to B}\)</span> is intuitive for the following
reasons. The core is to understand that a transformation can be thought
of in two ways: as a transformation of the <em>coordinate frame itself</em>,
and as transformation of the <em>coordinates relative to a coordinate
frame</em>. I’ll first give a non-formal explanation and later more formal
definitions of affine frames and their transformation.</p>
<p>Think of <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> as translating and rotating a real rigid
body: First, the body is located at the world origin; then the body is
moved by a translation <span class="math notranslate nohighlight">\(t\)</span>; then the body is rotated (around its
own center) as described by <span class="math notranslate nohighlight">\(R\)</span>. In that sense,
<span class="math notranslate nohighlight">\(T_{W\to B} =  \left(\begin{array}{cc}R &amp; t \\ 0
&amp; 1\end{array}\right)\)</span> describes the “forward” transformation of the
body. Consider that a coordinate frame <span class="math notranslate nohighlight">\(B\)</span> is attached to the
rigid body and a frame <span class="math notranslate nohighlight">\(W\)</span> to the world origin. Given a point
<span class="math notranslate nohighlight">\(p\)</span> in the world, we can express its coordinates relative to the
world, <span class="math notranslate nohighlight">\(p^W\)</span>, or relative to the body <span class="math notranslate nohighlight">\(p^B\)</span>. You can
convince yourself with simple examples that
<span class="math notranslate nohighlight">\(p^W = T_{W\to B}~ p^B\)</span>, that is, <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> <em>also</em>
describes the “backward” transformation of body-relative-coordinates to
world-relative-coordinates.</p>
<p>Formally: Let <span class="math notranslate nohighlight">\((A,V)\)</span> be an affine space. A coordinate frame is a
tuple <span class="math notranslate nohighlight">\((o,\boldsymbol e_1,..,\boldsymbol e_n)\)</span> of an origin
<span class="math notranslate nohighlight">\(o \in A\)</span> and basis vectors <span class="math notranslate nohighlight">\(\boldsymbol e_i \in V\)</span>. Given a
point <span class="math notranslate nohighlight">\(p\in A\)</span>, its coordinates <span class="math notranslate nohighlight">\(p_{1:n}\)</span> w.r.t. a
coordinate frame <span class="math notranslate nohighlight">\((o,\boldsymbol e_1,..,\boldsymbol e_n)\)</span> are
given implicitly via</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
p = o + \sum\nolimits_i p_i \boldsymbol e_i ~.\end{aligned}\]</div>
<p>A transformation <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> is a (“forward”) transformation of
the coordinate frame itself:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
(o^B,\boldsymbol e^B_1,..,\boldsymbol e^B_n)
 &amp;= (o^W + t, R\boldsymbol e^W_1,..,R\boldsymbol e^W_n)\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(t\in V\)</span> is the affine translation in <span class="math notranslate nohighlight">\(A\)</span> and
<span class="math notranslate nohighlight">\(R\)</span> the rotation in <span class="math notranslate nohighlight">\(V\)</span>. Note that the coordinates
<span class="math notranslate nohighlight">\((\boldsymbol e^B_i)^W_{1:n}\)</span> of a basis vector
<span class="math notranslate nohighlight">\(\boldsymbol e^B_i\)</span> relative to frame <span class="math notranslate nohighlight">\(W\)</span> are the columns of
<span class="math notranslate nohighlight">\(R\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\boldsymbol e^B_i
 &amp;= \sum_j (\boldsymbol e^B_i)^W_j \boldsymbol e^W_j
  = \sum_j R_{ji} \boldsymbol e^W_j\end{aligned}\]</div>
<p>Given this transformation of the coordinate frame itself, the
coordinates transform as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
p &amp;= o^W + \sum_i p^W_i~ \boldsymbol e^W_i \\
p &amp;= o^B + \sum_i p^B_i~ \boldsymbol e^B_i \\
  &amp;= o^W + t + \sum_i p^B_i~ (R \boldsymbol e^W_i) \\
  &amp;= o^W + \sum_i t^W_i~ e^W_i + \sum_j p^B_j~ (R \boldsymbol e^W_j) \\
  &amp;= o^W + \sum_i t^W_i~ e^W_i + \sum_j p^B_j~ (\sum_i R_{ij}~ \boldsymbol e^W_i) \\
  &amp;= o^W + \sum_i \Big[t^W_i + \sum_j R_{ij}~ p^B_j\Big]~ e^W_i \\
\Rightarrow
 &amp;~ p^W_i = t^W_i + \sum_j R_{ij}~ p^B_j ~.\end{aligned}\end{split}\]</div>
<p>Another way to express this formally: <span class="math notranslate nohighlight">\(T_{W\to B}\)</span> maps
<em>covariant</em> vectors (including “basis vectors”) forward, but
<em>contra-variant</em> vectors (including “coordinates”) backward.</p>
</section>
</section>
</section>
<section id="rai-references">
<h2>RAI references<a class="headerlink" href="#rai-references" title="Permalink to this heading"></a></h2>
<section id="nlp-interface">
<span id="secnlp"></span><h3>NLP interface<a class="headerlink" href="#nlp-interface" title="Permalink to this heading"></a></h3>
<p>A general non-linear mathematical program (NLP) is of the form</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{b_l\le x \le b_u}~ f(x) ~~~\text{s.t.}~~~ g(x)\le 0,~ h(x) = 0  ~,\end{aligned}\]</div>
<p>with <span class="math notranslate nohighlight">\(x\in{\mathbb{R}}^n\)</span>,
<span class="math notranslate nohighlight">\(f:~ {\mathbb{R}}^n \to {\mathbb{R}}\)</span>,
<span class="math notranslate nohighlight">\(g:~ {\mathbb{R}}^n \to {\mathbb{R}}^{d_g}\)</span>,
<span class="math notranslate nohighlight">\(h:~ {\mathbb{R}}^n \to {\mathbb{R}}^{d_h}\)</span>,
<span class="math notranslate nohighlight">\(b_l,b_u\in{\mathbb{R}}^n\)</span>. However, we want to explicitly account
for <strong>least squares</strong> costs (sum-of-squares), so that we extend the form
to</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{b_l\le x \le b_u}~ f(x) + r(x)^{\!\top\!}r(x) ~~~\text{s.t.}~~~ g(x)\le 0,~ h(x) = 0  ~,\end{aligned}\]</div>
<p>with <span class="math notranslate nohighlight">\(r:~ {\mathbb{R}}^n \to {\mathbb{R}}^{d_r}\)</span>. In technical
terms, the solver needs to be provided with:</p>
<p>the problem “signature”: dimension <span class="math notranslate nohighlight">\(n\)</span>, dimensions
<span class="math notranslate nohighlight">\(d_r, d_g, d_h\)</span>, bounds <span class="math notranslate nohighlight">\(b_l, b_u \in {\mathbb{R}}^n\)</span>,</p>
<p>functions <span class="math notranslate nohighlight">\(f, r, g, h\)</span>,   Jacobians for all,   Hessian for
<span class="math notranslate nohighlight">\(f\)</span>,</p>
<p>typically also an initialization sampler <span class="math notranslate nohighlight">\(x_0 \sim p(x)\)</span>, that
provides starting <span class="math notranslate nohighlight">\(x_0\)</span>.</p>
<p>Instead of providing a solver with separate functions
<span class="math notranslate nohighlight">\(f, r, g, h\)</span>, we instead provide only a single differentiable
<strong>feature</strong> function <span class="math notranslate nohighlight">\(\phi: X \to {\mathbb{R}}^K\)</span>, which stacks
all <span class="math notranslate nohighlight">\(f,r,g,h\)</span> components to a single vector,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\phi(x) =  \left(\begin{array}{c}f_1(x) \\ r_1(x) \\ h_1(x) \\ g_1(x) \\ h_2(x) \\ \vdots\end{array}\right)
~,\quad
\rho =  \left(\begin{array}{c}\texttt{f}\\ \texttt{sos}\\ \texttt{eq}\\ \texttt{ineq}\\ \texttt{eq}\\ \vdots\end{array}\right)  ~,\end{aligned}\end{split}\]</div>
<p>where the indicator vector <span class="math notranslate nohighlight">\(\rho\)</span> informs the solver which
components of <span class="math notranslate nohighlight">\(\phi\)</span> have to be treated as cost, sos, eq, or ineq.
(The order of stacking does not matter.) In this convention, the NLP
reads</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\min_{b_l\le x \le b_u}~ {{\bf 1}}^{\!\top\!}\phi_\texttt{f}(x) + \phi_\texttt{sos}(x)^{\!\top\!}\phi_\texttt{sos}(x)
  ~~\text{s.t.}~~\phi_\texttt{ineq}(x) \le 0,~ \phi_\texttt{eq}(x) = 0 ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(\phi_\texttt{sos}\)</span> is the subsets of <code class="docutils literal notranslate"><span class="pre">sos</span></code>-features, etc.
The solver needs to be provided with:</p>
<p>the problem “signature”: dimension <span class="math notranslate nohighlight">\(n\)</span>, feature types
<span class="math notranslate nohighlight">\(\rho\)</span>, bounds <span class="math notranslate nohighlight">\(b_l, b_u \in {\mathbb{R}}^n\)</span>,</p>
<p>a single differentiable <strong>feature</strong> function
<span class="math notranslate nohighlight">\(\phi: X \to {\mathbb{R}}^K\)</span>, with Jacobian functnio
<span class="math notranslate nohighlight">\(J = \partial_x \phi(x)\)</span>,</p>
<p>and typically also an initialization sampler <span class="math notranslate nohighlight">\(x_0 \sim p(x)\)</span>, that
provides starting <span class="math notranslate nohighlight">\(x_0\)</span>.</p>
<p>In the rai code, an NLP is therefore declared as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">signature</span>
<span class="n">uint</span> <span class="n">dimension</span><span class="p">;</span>  <span class="n">ObjectiveTypeA</span> <span class="n">featureTypes</span><span class="p">;</span>  <span class="n">arr</span> <span class="n">bounds_lo</span><span class="p">,</span> <span class="n">bounds_up</span><span class="p">;</span>

<span class="o">//</span><span class="n">essential</span> <span class="n">method</span>
<span class="n">virtual</span> <span class="n">void</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">arr</span><span class="o">&amp;</span> <span class="n">phi</span><span class="p">,</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">J</span><span class="p">,</span> <span class="n">const</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>

<span class="o">//</span><span class="n">optional</span>
<span class="n">virtual</span> <span class="n">arr</span>  <span class="n">getInitializationSample</span><span class="p">(</span><span class="n">const</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">previousOptima</span><span class="o">=</span><span class="p">{});</span>
<span class="n">virtual</span> <span class="n">void</span> <span class="n">getFHessian</span><span class="p">(</span><span class="n">arr</span><span class="o">&amp;</span> <span class="n">H</span><span class="p">,</span> <span class="n">const</span> <span class="n">arr</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="kinematic-features">
<h3>Kinematic Features<a class="headerlink" href="#kinematic-features" title="Permalink to this heading"></a></h3>
<p>The code has several kinematic features
<span class="math notranslate nohighlight">\(\phi: q \mapsto \phi(q)\in{\mathbb{R}}^D\)</span> pre-defined – see Table
[tabFeatures].</p>
</section>
<section id="graph-yaml-files">
<h3>Graph-Yaml Files<a class="headerlink" href="#graph-yaml-files" title="Permalink to this heading"></a></h3>
<p>We use yaml-style files throughout. These are the file representation of
internal data structures such as dictionaries (anytype key-value maps)
used for parameter files or other structure data, but esp. also graphs.
The key extensions relative to yaml are:</p>
<ul class="simple">
<li><p>An &#64;Include&#64; node allows to hierarchically include files. This means
that while each local file can be parsed with a standard yaml parser,
an outer loop has to check for &#64;Include&#64; nodes and coordinate loading
sub-files.</p></li>
<li><p>As an implication of the above, we allow for a special &#64;path&#64; type,
as URLs embraced by <code class="docutils literal notranslate"><span class="pre">&lt;...&gt;</span></code>. This becomes necessary as file values
need to be interpreted relative to the path of the loading file. So
when such a file is parsed we not only store the filename string, but
also the path of the loading file to ensure we know its absolute
path.</p></li>
<li><p>We also allow &#64;Edit&#64; and &#64;Delete&#64; tags, which allow us to
edit/overwrite the value of previously defined nodes, as well as
delete previously defined nodes.</p></li>
<li><p>Finally, the name of a node can include a list of parents: E.g. &#64;A (B
C): shape: box&#64; denotes a node with key &#64;A&#64; that is a child of &#64;B&#64;
and &#64;C&#64;. The semantics of this is that &#64;A&#64; is a (directed) edge
between B and C. This is analogous to a dot declaration &#64;B -&gt; C [
shape=box ]&#64;.</p></li>
<li><p>Note that all of the above is still yaml syntax, the outer parser
only adds additional interpretation of &#64;Include, Edit, Delete&#64; tags,
&#64;&lt;..&gt;&#64; values, and &#64;(..)&#64; in names.</p></li>
</ul>
<p>Within rai, .g-files are used to represent parameter files, robotic
configurations (<span class="math notranslate nohighlight">\(\sim\)</span> URDF), logic, factor graphs, optimization
problems. The underlying data structure is used, e.g., as any-type
container, Graph, or auto-convertion to python dictionaries.</p>
<p>The following example of a .g-file might help:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>## a trivial graph (all boolean-valued nodes)
x            # a vertex: key=x, value=true, parents=none
y            # another vertex: key=y, value=true, parents=none
(x y)        # an edge: key=none, value=true, parents=x y
(-1 -2)      # a hyperedge: key=none, value=true, parents=the previous edge and the y-node

## nodes with subgraphs as value
A { color:blue }         # key=A, value=&lt;Graph&gt;, parents=none
B { color:red, value:5 } # key=B, value=&lt;Graph&gt;, parents=none
C(A,B) { width:2 }       # key=C, value=&lt;Graph&gt;, parents=A B
hyperedge(A B C) : 5     # key=hyperedge, value=5, parents=A B C

## standard value types
a:string      # MT::String (except for keywords &#39;true&#39; and &#39;false&#39; and &#39;Mod&#39; and &#39;Include&#39;)
b:&quot;STRING&quot;    # MT::String (does not require a &#39;:&#39;)
c:&#39;file.txt&#39;  # MT::FileToken (does not require a &#39;:&#39;)
d:-0.1234     # double
e:[1 2 3 0.5] # MT::arr (does not require a &#39;:&#39;)
#f:(c d e)    # DEPRECATED!! MT::Array&lt;*Node&gt; (list of other nodes in the Graph)
g!            # bool (default: true, !means false)
h:true        # bool
i:false       # bool
j:{ a:0 }     # sub-Graph (special: does not require a &#39;:&#39;)

## parsing: : {..} (..) , and \n are separators for parsing key-value-pairs
b0:false b1, b2() b3    # 4 boolean nodes with keys &#39;b0&#39;, &#39;b1&#39;, &#39;b2&#39;, &#39;b3&#39;
k:{ a, b:0.2 x:&quot;hallo&quot;     # sub-Graph with 6 nodes
  y
  z():filename.org x }

## special Node Keys

# editing: after reading all nodes, the Graph takes all Edit nodes, deletes the Edit tag, and calls a edit()
# this example will modify/append the respective attributes of k
Edit k { y:false, z:otherString, b:7, c:newAttribute }

# including
Include: &#39;example_include.g&#39;   # first creates a normal FileToken node then opens and includes the file directly

## strange notations
a()       # key=a, value=true, parents=none
()        # key=none, value=true, parents=none
[1 2 3 4] # key=none, value=MT::arr, parents=none
</pre></div>
</div>
<p>Subgraphs may contain nodes that have parents from the containing graph,
or from other subgraphs of the containing graph. Some methods of the
<code class="docutils literal notranslate"><span class="pre">Graph</span></code> class (to find nodes by key or type) allow to specify whether
also nodes in subgraphs or parentgraphs are to be searched. This
connectivity across (sub)-graphs e.g. allows to represent logic
knowledge bases.</p>
</section>
<section id="yaml-style-files-to-describe-robot-configurations">
<h3>yaml-style files to describe robot configurations<a class="headerlink" href="#yaml-style-files-to-describe-robot-configurations" title="Permalink to this heading"></a></h3>
<p>We use .g-files to represent robot/world configurations. .g-files
describe a general graph data structure as explained in :ref:‘refGraph‘.
But for robot configurations it is rather simple: Everly node describes
a frame, and is described by three things:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">frame</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span> <span class="p">(</span> <span class="o">&lt;</span><span class="n">parent</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="o">&lt;</span><span class="n">attributes</span><span class="o">&gt;</span> <span class="p">}</span>
</pre></div>
</div>
<p>where “&lt;parent&gt;“ needs to be a previously defined frame, or omitted, if
the frame is a root frame. The attributes defined properties of the
frame, such as its pose, shape, joint properties, etc.</p>
<p>Here is an example taken from the “test/Kin/kin“:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">stem</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">.5</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span><span class="n">capsule</span><span class="p">,</span> <span class="n">mass</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">:[</span><span class="mi">1</span> <span class="mf">.05</span><span class="p">]</span> <span class="p">}</span>

<span class="n">joint1_pre</span> <span class="p">(</span><span class="n">stem</span><span class="p">)</span> <span class="p">{</span> <span class="n">Q</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">.5</span><span class="p">)</span> <span class="n">d</span><span class="p">(</span><span class="mi">90</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="n">joint1</span> <span class="p">(</span><span class="n">arm1</span><span class="p">)</span> <span class="p">{</span> <span class="n">joint</span><span class="p">:</span><span class="n">hingeX</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span><span class="o">&lt;</span><span class="n">d</span><span class="p">(</span><span class="o">-</span><span class="mi">30</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">}</span>
<span class="n">arm1</span> <span class="p">(</span><span class="n">joint1</span><span class="p">)</span> <span class="p">{</span> <span class="n">Q</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">.15</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span><span class="n">capsule</span><span class="p">,</span> <span class="n">mass</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">:[</span><span class="mf">.3</span> <span class="mf">.05</span><span class="p">]</span> <span class="p">}</span>

<span class="n">arm2</span> <span class="p">{</span> <span class="n">shape</span><span class="p">:</span><span class="n">capsule</span><span class="p">,</span> <span class="n">mass</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">:[</span><span class="mf">.3</span> <span class="mf">.05</span><span class="p">]</span> <span class="p">}</span>
<span class="n">eff</span> <span class="p">{</span> <span class="n">shape</span><span class="p">:</span><span class="n">capsule</span><span class="p">,</span> <span class="n">mass</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">:[</span><span class="mf">.3</span> <span class="mf">.05</span><span class="p">]</span> <span class="p">}</span>

<span class="n">joint2</span> <span class="p">(</span><span class="n">arm1</span> <span class="n">arm2</span><span class="p">)</span> <span class="p">{</span> <span class="n">joint</span><span class="p">:</span><span class="n">hingeX</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">.15</span><span class="p">)</span> <span class="n">d</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span><span class="o">&lt;</span><span class="n">d</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">.15</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">}</span>
<span class="n">joint3</span> <span class="p">(</span><span class="n">arm2</span> <span class="n">eff</span> <span class="p">)</span> <span class="p">{</span> <span class="n">joint</span><span class="p">:</span><span class="n">hingeX</span><span class="p">,</span> <span class="n">A</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">.15</span><span class="p">)</span> <span class="n">d</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Q</span><span class="p">:</span><span class="o">&lt;</span><span class="n">d</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">B</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mi">0</span> <span class="mi">0</span> <span class="mf">.15</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">}</span>

<span class="n">target</span> <span class="p">{</span> <span class="n">X</span><span class="p">:</span><span class="o">&lt;</span><span class="n">t</span><span class="p">(</span><span class="mf">.0</span> <span class="mf">.2</span> <span class="mf">1.7</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span><span class="n">sphere</span><span class="p">,</span> <span class="n">mass</span><span class="p">:</span><span class="mf">.001</span><span class="p">,</span> <span class="n">size</span><span class="p">:[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mf">.02</span><span class="p">],</span> <span class="n">color</span><span class="p">:[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
</pre></div>
</div>
<p>The first line defines a frame “stem“, which has absolute pose “&lt;t(0 0
.5)&gt;“ (pose specifications are described below). It also has a shape
attached, namely a capsule of length 1 and radius .05. And it has
inertial mass attached, namely with mass 1.</p>
<p>The 2nd to 4th line form a block of 3 new frames: the <code class="docutils literal notranslate"><span class="pre">joint1_pre</span></code>
frame is child of step, which fixed relative transformation
<code class="docutils literal notranslate"><span class="pre">&lt;t(0</span> <span class="pre">0</span> <span class="pre">.5)</span> <span class="pre">d(90</span> <span class="pre">1</span> <span class="pre">0</span> <span class="pre">0)&gt;</span></code> (.5 meter up, 90 degress rotation about x).
The <code class="docutils literal notranslate"><span class="pre">joint1</span></code> frame is a child of <code class="docutils literal notranslate"><span class="pre">joint1_pre</span></code>. But this frame is
special! It is a joint, which means that its relative transformation to
the parent is not fixed, but varies with joint dofs. Here, it is 1 joint
dofs describing a hinge joint about the parent’s x-axis. This joint is
here initialized to non-zero, namely to a relative transform
<code class="docutils literal notranslate"><span class="pre">&lt;d(-30</span> <span class="pre">1</span> <span class="pre">0</span> <span class="pre">0)&gt;</span></code>. The <code class="docutils literal notranslate"><span class="pre">arm1</span></code> frame is then a child of <code class="docutils literal notranslate"><span class="pre">joint1</span></code>,
with a relative transform <code class="docutils literal notranslate"><span class="pre">&lt;t(0</span> <span class="pre">0</span> <span class="pre">.15)&gt;</span></code>, a capsule shape attached,
and mass.</p>
<p>This is a typical example for a chain of frames from one link, via a
joint, to the next. All robot configurations are just trees; and the
configuration file simply defines frames one-by-one, where each frame
may have 1 parent frame.</p>
<p>The next two lines define two more frames <code class="docutils literal notranslate"><span class="pre">arm2</span></code> and <code class="docutils literal notranslate"><span class="pre">eff</span></code> mass and
capsule shapes; but they’re yet all located at zero absolute pose. The
following two lines are actually a short hand notation to introduce a
joint frames between arm1 and arm2 (arm2 and arm3) in retrospect. The
<code class="docutils literal notranslate"><span class="pre">joint2</span></code> declaration implicitly first defines a <code class="docutils literal notranslate"><span class="pre">joint2_pre</span></code> child
of arm1 with fixed relative transformation A; then the <code class="docutils literal notranslate"><span class="pre">joint2</span></code> chile
of <code class="docutils literal notranslate"><span class="pre">joint2_pre</span></code> with hinge joint and initial transformation Q; then
attaches the arm2 frame as its child with fixed relative transformation
B. So this is a typical short hand to specify a joint (more similarly to
how its done in URDF). But the generated underlying data structure is
just a tree of frames.</p>
<section id="editing-using-kinedit">
<h4>Editing using <code class="docutils literal notranslate"><span class="pre">kinEdit</span></code><a class="headerlink" href="#editing-using-kinedit" title="Permalink to this heading"></a></h4>
<p>Whenever working with .g-files, you should try to display them using the
<code class="docutils literal notranslate"><span class="pre">$RAI/bin/kinEdit</span></code> command line tool. CMake automatically compiles it;
otherwise call ’make bin’ in <code class="docutils literal notranslate"><span class="pre">$RAI</span></code> to compile this. Then you can call
<code class="docutils literal notranslate"><span class="pre">kinEdit</span> <span class="pre">someFile.g</span></code> on any model file. (In python, the equivalence is
to reload the configuration from file repeatedly.) Whenever <code class="docutils literal notranslate"><span class="pre">kinEdit</span></code>
reads a file, it also outputs a file <code class="docutils literal notranslate"><span class="pre">z.g</span></code> and <code class="docutils literal notranslate"><span class="pre">z.urdf</span></code> of what it
read. Sometimes it is useful to look into this. It can also be used to
clean and prune kinematic structures.</p>
<p>But more than that, you can keep the display open when editing the file
in any text editor. Whenever you save the file the display will notice
it, reload the file, and display the updated model. This allows some
degree of continuous editing. You might sometimes have to hit enter in
the window to enforce reloading. The little tool tries to catch and
report on syntax errors and be robust, but it crashes on some syntax
errors and then needs to be restarted manually.</p>
</section>
<section id="import-from-urdf">
<h4>Import from URDF<a class="headerlink" href="#import-from-urdf" title="Permalink to this heading"></a></h4>
<p>You can convert URDF files to .g-files using the <code class="docutils literal notranslate"><span class="pre">rai/bin/urdf2rai.py</span></code>
script. However, the overall conversion is only partially automatic. The
resulting g-file encodes the full kinematic structure, but the mesh
files usually require manual fiddling. First, in the g-file, you have to
change the path to their location in the file system (removing the
’package’ part). Potentially that’s all you need. However, the rai code
calls various collision libraries that need clean and correct
(orientation, holes, etc) mesh files. Those that come with URDF files
are typically not clean and correct. I typically use meshlab (the
command line tool) to automatically clean and compress meshes into ply
files.</p>
<p>The best guide for the whole conversion pipeline is hubo/HOWTO.sh in the
rai-robotModels repository, which also describes mesh cleaning scripts.
We also managed to import a [full
kitchen](<a class="reference external" href="https://github.com/MarcToussaint/rai-robotModels/tree/master/bremenKitchen">https://github.com/MarcToussaint/rai-robotModels/tree/master/bremenKitchen</a>)
from unreal, where we first exported the description to JSON. There are
also some working examples to import ‘gltf‘.</p>
<p>Finally, the collada file format can represent trees of frames and
objects, which can be loaded. This can be augmented with just a little
extra information on joints to make this a properly articulated robot
world.</p>
</section>
<section id="notation-to-specify-transformations">
<h4>Notation to specify transformations<a class="headerlink" href="#notation-to-specify-transformations" title="Permalink to this heading"></a></h4>
<p>Transformation can always be specified as 7-vectors
<code class="docutils literal notranslate"><span class="pre">Q:[p1</span> <span class="pre">p2</span> <span class="pre">p3</span> <span class="pre">q0</span> <span class="pre">q1</span> <span class="pre">q2</span> <span class="pre">q3]</span></code> (position, quaternion), or also 3- or
4-vectors if you only want to set position or orientation. But this is
not always intuitive for human editing. Therefore, the bracket notation
<code class="docutils literal notranslate"><span class="pre">&lt;...&gt;</span></code> allows for another notation, namely as a chaining of little
interpretable transformations, as in the old turtle language.</p>
<p>Specifically, you specify a transform by chaining:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span><span class="p">(</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span>       <span class="c1"># translation by (x,y,z)</span>
<span class="n">q</span><span class="p">(</span><span class="n">q0</span> <span class="n">q1</span> <span class="n">q2</span> <span class="n">q3</span><span class="p">)</span> <span class="c1"># rotation by a quaternion</span>
<span class="n">r</span><span class="p">(</span><span class="n">r</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span>     <span class="c1"># rotation by `r` _radians_ around the axis (x,y,z)</span>
<span class="n">d</span><span class="p">(</span><span class="n">d</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="p">)</span>     <span class="c1"># rotation by `d` _degrees_ around the axis (x,y,z)</span>
<span class="n">E</span><span class="p">(</span><span class="n">r</span> <span class="n">p</span> <span class="n">y</span><span class="p">)</span>       <span class="c1"># rotation by roll-pitch-yaw Euler angles</span>
</pre></div>
</div>
</section>
<section id="joint-types">
<h4>Joint types<a class="headerlink" href="#joint-types" title="Permalink to this heading"></a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">libry.JT</span></code> enum (in python; or rai::JointType in C++) lists all
available joint type. Currently these are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">hingeX</span><span class="p">,</span> <span class="n">hingeY</span><span class="p">,</span> <span class="n">hingeZ</span><span class="p">,</span> <span class="n">transX</span><span class="p">,</span> <span class="n">transY</span><span class="p">,</span> <span class="n">transZ</span><span class="p">,</span> <span class="n">transXY</span><span class="p">,</span> <span class="n">trans3</span><span class="p">,</span> <span class="n">transXYPhi</span><span class="p">,</span> <span class="n">universal</span><span class="p">,</span> <span class="n">rigid</span><span class="p">,</span> <span class="n">quatBall</span><span class="p">,</span> <span class="n">phiTransXY</span><span class="p">,</span> <span class="n">XBall</span><span class="p">,</span> <span class="n">free</span><span class="p">,</span> <span class="n">tau</span>
</pre></div>
</div>
<p>A quatBall is a quaternion ball joint with 4 dofs (that supports all
differentiability and optimization); a free joint is a full 7 dof joint;
a rigid joint might seem redundant, but internally it sometimes markes a
break between separate objects (like an object sitting rigidly on a
table) rather than having multiple shapes attached to the same object.</p>
<p>The joint’s dofs can be initialized equivalently either with a <code class="docutils literal notranslate"><span class="pre">q</span></code>
attribute (defining the dofs values), or a <code class="docutils literal notranslate"><span class="pre">Q</span></code> attribute (defining the
resulting relative transformation generated by the joint).</p>
</section>
</section>
</section>
<section id="cameras">
<h2>Cameras<a class="headerlink" href="#cameras" title="Permalink to this heading"></a></h2>
<section id="image-camera-world-coordinates">
<h3>Image, Camera, &amp; World Coordinates<a class="headerlink" href="#image-camera-world-coordinates" title="Permalink to this heading"></a></h3>
<p>In this section, we use the following notation for coordinates of a 3D
point:</p>
<ul class="simple">
<li><p>world coordinates <span class="math notranslate nohighlight">\(X\)</span>,</p></li>
<li><p>camera coordinates <span class="math notranslate nohighlight">\(x\)</span> (so that <span class="math notranslate nohighlight">\(X = T x\)</span>, where
<span class="math notranslate nohighlight">\(T\equiv T_{W\to C}\)</span> is the camera position/orientation, also
called <strong>extrinsic parameter</strong>),</p></li>
<li><p>image coordinates <span class="math notranslate nohighlight">\(u=(u_x,u_y,u_d)\)</span>, with the pixel coordinates
<span class="math notranslate nohighlight">\((u_x,u_y)\)</span> and depth coordinate <span class="math notranslate nohighlight">\(u_d\)</span>, details as
followed.</p></li>
</ul>
<p>The pixel coordinates <span class="math notranslate nohighlight">\((u_x,u_y)\)</span> indicate where a point appears
on the image plane. The <span class="math notranslate nohighlight">\(x\)</span>-axis always points to the right, but
there are two conventions for the <span class="math notranslate nohighlight">\(y\)</span>-axis:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(y\)</span>-up: The <span class="math notranslate nohighlight">\(y\)</span>-axis points upward. This is consistent to
how a diagram is typically drawn on paper: <span class="math notranslate nohighlight">\(x\)</span>-axis right,
<span class="math notranslate nohighlight">\(y\)</span>-axis up. However, a consequence is that the <span class="math notranslate nohighlight">\(z\)</span>-axis
then points backward, i.e., pixels in front of the camera have
negative depth <span class="math notranslate nohighlight">\(u_d\)</span>.</p></li>
<li><p><span class="math notranslate nohighlight">\(y\)</span>-down: The <span class="math notranslate nohighlight">\(y\)</span>-axis points down. This is consistent to
how pixels are typically indexed in image data: counting rows from
top to bottom. So when defining pixel coordinates <span class="math notranslate nohighlight">\((u_x,u_y)\)</span>
literally to be pixel indices in image data, <span class="math notranslate nohighlight">\(y\)</span>-down is the
natural convention. A consequence is that the <span class="math notranslate nohighlight">\(z\)</span>-axis points
forward, i.e., pixels in front of the camera have a positive depth
<span class="math notranslate nohighlight">\(u_d\)</span>, which might also be more intuitive.</p></li>
</ul>
<p>The transformation from camera coordinates <span class="math notranslate nohighlight">\(x\)</span> to image
coordinates <span class="math notranslate nohighlight">\(u\)</span> is involves perspective projection. For better
readability, let’s write – only for this equation –
<span class="math notranslate nohighlight">\(x \equiv (x,y,z)\)</span>. Then the mapping is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\label{eqxtou}
u =  \left(\begin{array}{c}u_x \\ u_y \\ u_d\end{array}\right)
&amp;=  \left(\begin{array}{c}(f_x x + s y)/z + c_x\\ f_y y/z + c_y \\ z\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
<p>Here, the five so-called <strong>intrinsic parameters</strong>
<span class="math notranslate nohighlight">\(f_x,f_y,c_x,c_y,s\)</span> are the focal length <span class="math notranslate nohighlight">\(f_x,f_y\)</span>, the
image center <span class="math notranslate nohighlight">\(c_x,c_y\)</span>, and a image skew <span class="math notranslate nohighlight">\(s\)</span> (which is
usually zero). E.g., for an image of height <span class="math notranslate nohighlight">\(H\)</span> and width
<span class="math notranslate nohighlight">\(W\)</span>, and vertical full view angle <span class="math notranslate nohighlight">\(\alpha\)</span>, we typically
have an image center <span class="math notranslate nohighlight">\(c_x \approx H/2, c_y \approx W/2\)</span> and a
focal length <span class="math notranslate nohighlight">\(f_y
= \frac{H}{2 \tan(\alpha/2)}\)</span>, e.g., for <span class="math notranslate nohighlight">\(\alpha=90^\circ\)</span>,
<span class="math notranslate nohighlight">\(f_y = H/2\)</span>. For a typical camera <span class="math notranslate nohighlight">\(f_x \approx f_y\)</span>.</p>
<p>Inversely, if we have image coordinates <span class="math notranslate nohighlight">\(u\)</span> and want to convert to
cartesian camera coordinates, we have (assuming <span class="math notranslate nohighlight">\(s=0\)</span>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
x
&amp;=  \left(\begin{array}{c}(u_x - c_x) u_z / f_x\\ (u_y - c_y) u_z / f_y \\ u_z\end{array}\right)  ~.\end{aligned}\end{split}\]</div>
</section>
<section id="homogeneous-coordinates-camera-matrix-p">
<h3>Homogeneous coordinates &amp; Camera Matrix <span class="math notranslate nohighlight">\(P\)</span><a class="headerlink" href="#homogeneous-coordinates-camera-matrix-p" title="Permalink to this heading"></a></h3>
<p>First a brief definition: <em>A homogeneous coordinate
:math:`boldsymbol x=(x_1,..,x_n,w)` is a (redundant) description of the
:math:`n`-dim point</em></p>
<div class="math notranslate nohighlight">
\[\begin{split}{\cal P}(\boldsymbol x)=  \left(\begin{array}{c}x_1/w \\ \vdots \\ x_n/w\end{array}\right)  ~.\end{split}\]</div>
<p>Note that two coordinates <span class="math notranslate nohighlight">\((x_1,..,x_n,w)\)</span> and
<span class="math notranslate nohighlight">\((\lambda x_1,..,\lambda x_n,\lambda w)\)</span> are “equivalent” in that
they describe the same point. The operation <span class="math notranslate nohighlight">\({\cal P}\)</span> is
<em>non-linear</em> and called <strong>perspective projection</strong>. In this section, we
write homogeneous coordinates in bold <span class="math notranslate nohighlight">\(\boldsymbol x\)</span>.</p>
<p>Back to our camera setting: Let <span class="math notranslate nohighlight">\(\boldsymbol x\)</span> and
<span class="math notranslate nohighlight">\(\boldsymbol X\)</span> be homogeneous camera and world coordinates of a
point (typically both have <span class="math notranslate nohighlight">\(w=1\)</span> as last entry). Then the pose
transformation <span class="math notranslate nohighlight">\(T\)</span> can be written as <span class="math notranslate nohighlight">\(4\times\)</span> matrix such
that</p>
<div class="math notranslate nohighlight">
\[\boldsymbol x = T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} \boldsymbol X ~.\]</div>
<p>Given camera coordinates <span class="math notranslate nohighlight">\(x = ``(x,y,z)''\)</span>, we can write
([eqxtou])</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\boldsymbol u
&amp;= K x
=  \left(\begin{array}{c}f_x x + s y + c_x z\\ f_y y + c_y z \\ z\end{array}\right)  ~,\quad
K =  \left(\begin{array}{ccc}f_x &amp; s &amp; c_x \\ &amp; f_y &amp; c_y \\ &amp; &amp; 1 \end{array}\right)  ~,\quad
{\cal P}(\boldsymbol u)
=  \left(\begin{array}{c}  (f_x x + s y)/z + c_x\\ f_y y/z + c_y \end{array}\right)  ~,\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol u\)</span> are homogeneous <em>pixel</em> coordinates, and
<span class="math notranslate nohighlight">\({\cal P}(\boldsymbol u)\)</span> the actual pixel coordinates, which
would have to be augmented with <span class="math notranslate nohighlight">\(z\)</span> again to get the <span class="math notranslate nohighlight">\(u\)</span>
including depth coordinate.</p>
<p>The <span class="math notranslate nohighlight">\(3\times 3\)</span> matrix <span class="math notranslate nohighlight">\(K\)</span> includes the 5 general intrinsic
parameters. Writing the inverse transformation
<span class="math notranslate nohighlight">\(T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span> as a
<span class="math notranslate nohighlight">\(3\times 4\)</span> matrix
<span class="math notranslate nohighlight">\(\left(\begin{array}{cc}R^{\!\top\!}&amp; -R^{\!\top\!}t\end{array}\right)\)</span>
with rotation <span class="math notranslate nohighlight">\(R\)</span> and translation <span class="math notranslate nohighlight">\(t\)</span>, we can write the
relation between <span class="math notranslate nohighlight">\(\boldsymbol u\)</span> and homogeneous world coordinates
<span class="math notranslate nohighlight">\(\boldsymbol X\)</span> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\boldsymbol u = P \boldsymbol X
~,\quad\text{with~} P =  \left(\begin{array}{cc}K &amp; 0\end{array}\right) ~ T^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} =  \left(\begin{array}{cc}K &amp; 0\end{array}\right) ~  \left(\begin{array}{cc}R^{\!\top\!}&amp; -R^{\!\top\!}t \\ &amp; 1\end{array}\right)  =  \left(\begin{array}{cc}KR^{\!\top\!}&amp; -KR^{\!\top\!}t\end{array}\right)  ~,\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(P\)</span> is the <span class="math notranslate nohighlight">\(3\times 4\)</span> <strong>camera matrix</strong>, which
subsumes 5 intrinsic and 6 extrinsic (3 rotation, 3 translation)
parameters. Except for absolute scaling (the 1 in the definition of
<span class="math notranslate nohighlight">\(K\)</span>), this fully parameterizes a general affine transform.</p>
</section>
<section id="calibration-as-estimating-p-k-r-t-from-depth-data">
<h3>Calibration as Estimating <span class="math notranslate nohighlight">\(P,K,R,t\)</span> from Depth Data<a class="headerlink" href="#calibration-as-estimating-p-k-r-t-from-depth-data" title="Permalink to this heading"></a></h3>
<p>Assuming we have data of pairs <span class="math notranslate nohighlight">\((\boldsymbol u, \boldsymbol X)\)</span>,
we can use the basic equation <span class="math notranslate nohighlight">\(\boldsymbol u = P \boldsymbol X\)</span> to
retrieve <span class="math notranslate nohighlight">\(P\)</span> in closed from, and in a second step retrieve the
intrinsic and extrinsic camera parameters from <span class="math notranslate nohighlight">\(P\)</span>. Note that here
we discuss the situation where we have the “right” <span class="math notranslate nohighlight">\(\boldsymbol u\)</span>
in the data – and not only the pixel coordinates
<span class="math notranslate nohighlight">\({\cal P}(\boldsymbol u)\)</span>! This means that we assume we have data
entries <span class="math notranslate nohighlight">\(\boldsymbol u = (u_x u_d, u_y u_d, u_d)\)</span> which includes
the true depth <span class="math notranslate nohighlight">\(u_d\)</span>. So this method is only applicable when we
want to calibrate a depth camera.</p>
<p>Given data <span class="math notranslate nohighlight">\(D = \{(\boldsymbol u_i, \boldsymbol X_i)\}_{i=1}^n\)</span>,
we want to minimize the squared error</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
\argmin_P \sum_i (\boldsymbol u_i - P \boldsymbol X_i)^2 = [U - P X]^2 ~,\end{aligned}\]</div>
<p>where <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(X\)</span> are the stacked <span class="math notranslate nohighlight">\(\boldsymbol u_i\)</span>
and <span class="math notranslate nohighlight">\(\boldsymbol X_i\)</span>, respectively. The solution is
<span class="math notranslate nohighlight">\(P = U^{\!\top\!}X (X^{\!\top\!}X)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>.
Comparing with the form of <span class="math notranslate nohighlight">\(P\)</span> above, we can decompose it and
extract explicit <span class="math notranslate nohighlight">\(K, R, t\)</span> using</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  (K,R^{\!\top\!}) &amp;\gets \text{RQ-decomposition}(P_{1:3,:}) \\
  t &amp;\gets -(K R^{\!\top\!})^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} P_{4,:}\end{aligned}\end{split}\]</div>
<p>However, when defining
<span class="math notranslate nohighlight">\(\bar u = (\boldsymbol u,1) = (u_x u_z, u_y u_z, u_z, 1)\)</span> (with
additional 1 agumented), we can also write the inverse linear relation
to the non-homogeneous world coordinate <span class="math notranslate nohighlight">\(X\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
X  = P^+ \bar u~,\quad\text{with~} P^+ =  \left(\begin{array}{cc}R K^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} &amp; t\end{array}\right)  \bar u~,\end{aligned}\]</div>
<p>Using data <span class="math notranslate nohighlight">\(X\)</span> (<span class="math notranslate nohighlight">\(3\times n\)</span>) and <span class="math notranslate nohighlight">\(U\)</span>
(<span class="math notranslate nohighlight">\(4\times n\)</span>) the optimum is
<span class="math notranslate nohighlight">\(P^+ = X^{\!\top\!}U (U^{\!\top\!}U)^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1}\)</span>.
We can decompose it using</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  t &amp;\gets P^+_{3,:} \\
  (K,R^{\!\top\!}) &amp;\gets \text{RQ-decomposition}( [P^+_{1:3,:}]^{{\hspace{-0.0pt}\textrm{-}\hspace{-0.5pt}}1} ]\end{aligned}\end{split}\]</div>
</section>
</section>
<section id="placeholder-1">
<span id="id4"></span><h2>Placeholder<a class="headerlink" href="#placeholder-1" title="Permalink to this heading"></a></h2>
<section id="shapes">
<span id="secshapes"></span><h3>Shapes<a class="headerlink" href="#shapes" title="Permalink to this heading"></a></h3>
</section>
<section id="kinematics-formally">
<span id="seckinematics"></span><h3>Kinematics formally<a class="headerlink" href="#kinematics-formally" title="Permalink to this heading"></a></h3>
<p>– Switching Kinematics?</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id5" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">1</a><span class="fn-bracket">]</span></span>
<p>Transformation of accelerations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\dot v
 &amp;= \dot v_1
      + \dot w_1 \times (r_1 \cdot t_2)
      + w_1 \times (w_1 \times (r_1 \cdot t_2))\\
      &amp;\quad+ 2\, w_1 \times (r_1 \cdot v_2)
      + r_1 \cdot \dot v_2 \\
\dot w
 &amp;= \dot w_1 + w_1 \times (r_1 \cdot w_2) + r_1 \cdot \dot w_2\end{aligned}\end{split}\]</div>
<p>Used identities: for any vectors <span class="math notranslate nohighlight">\(a,b,c\)</span> and rotation
<span class="math notranslate nohighlight">\(r\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
&amp;r \cdot (a \times b) = (r \cdot a) \times (r \cdot b)\\
&amp; a \times (b \times c) = b (a c) - c (ab) \\
&amp;\partial_t (r \cdot a) = w \times (r \cdot a) + r \cdot \dot a \\
%&amp; \del_t (r_0 \circ r \cdot t)
% = w_0 \times (r_0 \circ r \cdot t)
% + r_0 \cdot \[w \times (r \cdot t) + r \cdot v\]
% = (w_0 + r_0 \cdot w) \times (r_0 \circ r \cdot t) + r_0 r \cdot v  \\
&amp; \partial_t (w \times a) = \dot w \times t + w \times \dot a\end{aligned}\end{split}\]</div>
</aside>
<aside class="footnote brackets" id="id6" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>There is ways to handle the invariance w.r.t. quaternion sign
properly.</p>
</aside>
</aside>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../tutorials/script5-PathFind.html" class="btn btn-neutral float-left" title="Path finding example" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../old/old.html" class="btn btn-neutral float-right" title="Old Material" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Marc Toussaint.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>